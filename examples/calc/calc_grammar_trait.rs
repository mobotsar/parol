// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use crate::calc_grammar::CalcGrammar;
use id_tree::Tree;
use miette::{miette, Result};
use parol_runtime::lexer::OwnedToken;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

//
// Output Types of productions deduced from the structure of the transformed grammar
//

/// Type derived for production 0
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Calc0 {
    calc_lst1_0: Box<CalcLst1>,
}

/// Type derived for production 1
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct CalcLst1_1 {
    calc_lst1_itm1_0: Box<CalcLst1Itm1>,
    calc_lst1_1: Box<CalcLst1>,
}

/// Type derived for production 2
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct CalcLst1Itm1_2 {
    instruction_0: Box<Instruction>,
    semicolon_1: OwnedToken, /* ; */
}

/// Type derived for production 3
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct CalcLst1_3 {}

/// Type derived for production 4
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Instruction4 {
    assignment_0: Box<Assignment>,
}

/// Type derived for production 5
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Instruction5 {
    logical_or_0: Box<LogicalOr>,
}

/// Type derived for production 6
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct EqualityOp6 {
    equality_op_0: OwnedToken, /* ==|!= */
}

/// Type derived for production 7
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AssignOp7 {
    assign_op_0: OwnedToken, /* (\+|-|\*|/|%|<<|>>|&|\^|\|)?= */
}

/// Type derived for production 8
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AssignItem8 {
    id_0: Box<Id>,
    assign_op_1: Box<AssignOp>,
}

/// Type derived for production 9
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Assignment9 {
    assign_item_0: Box<AssignItem>,
    assignment_lst1_1: Box<AssignmentLst1>,
    logical_or_2: Box<LogicalOr>,
}

/// Type derived for production 10
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AssignmentLst1_10 {
    assignment_lst1_itm1_0: Box<AssignmentLst1Itm1>,
    assignment_lst1_1: Box<AssignmentLst1>,
}

/// Type derived for production 11
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AssignmentLst1Itm1_11 {
    assign_item_0: Box<AssignItem>,
}

/// Type derived for production 12
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AssignmentLst1_12 {}

/// Type derived for production 13
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalOr13 {
    logical_and_0: Box<LogicalAnd>,
    logical_or_lst1_1: Box<LogicalOrLst1>,
}

/// Type derived for production 14
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalOrLst1_14 {
    logical_or_lst1_itm1_0: Box<LogicalOrLst1Itm1>,
    logical_or_lst1_1: Box<LogicalOrLst1>,
}

/// Type derived for production 15
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalOrLst1Itm1_15 {
    logical_or_item_0: Box<LogicalOrItem>,
}

/// Type derived for production 16
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalOrLst1_16 {}

/// Type derived for production 17
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalOrOp17 {
    logical_or_op_0: OwnedToken, /* \|\| */
}

/// Type derived for production 18
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalOrItem18 {
    logical_or_op_0: Box<LogicalOrOp>,
    logical_and_1: Box<LogicalAnd>,
}

/// Type derived for production 19
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalAnd19 {
    bitwise_or_0: Box<BitwiseOr>,
    logical_and_lst1_1: Box<LogicalAndLst1>,
}

/// Type derived for production 20
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalAndLst1_20 {
    logical_and_lst1_itm1_0: Box<LogicalAndLst1Itm1>,
    logical_and_lst1_1: Box<LogicalAndLst1>,
}

/// Type derived for production 21
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalAndLst1Itm1_21 {
    logical_and_item_0: Box<LogicalAndItem>,
}

/// Type derived for production 22
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalAndLst1_22 {}

/// Type derived for production 23
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalAndOp23 {
    logical_and_op_0: OwnedToken, /* && */
}

/// Type derived for production 24
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalAndItem24 {
    logical_and_op_0: Box<LogicalAndOp>,
    bitwise_or_1: Box<BitwiseOr>,
}

/// Type derived for production 25
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseOr25 {
    bitwise_and_0: Box<BitwiseAnd>,
    bitwise_or_lst1_1: Box<BitwiseOrLst1>,
}

/// Type derived for production 26
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseOrLst1_26 {
    bitwise_or_lst1_itm1_0: Box<BitwiseOrLst1Itm1>,
    bitwise_or_lst1_1: Box<BitwiseOrLst1>,
}

/// Type derived for production 27
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseOrLst1Itm1_27 {
    bitwise_or_item_0: Box<BitwiseOrItem>,
}

/// Type derived for production 28
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseOrLst1_28 {}

/// Type derived for production 29
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseOrOp29 {
    bitwise_or_op_0: OwnedToken, /* \| */
}

/// Type derived for production 30
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseOrItem30 {
    bitwise_or_op_0: Box<BitwiseOrOp>,
    bitwise_and_1: Box<BitwiseAnd>,
}

/// Type derived for production 31
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseAnd31 {
    equality_0: Box<Equality>,
    bitwise_and_lst1_1: Box<BitwiseAndLst1>,
}

/// Type derived for production 32
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseAndLst1_32 {
    bitwise_and_lst1_itm1_0: Box<BitwiseAndLst1Itm1>,
    bitwise_and_lst1_1: Box<BitwiseAndLst1>,
}

/// Type derived for production 33
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseAndLst1Itm1_33 {
    bitwise_and_item_0: Box<BitwiseAndItem>,
}

/// Type derived for production 34
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseAndLst1_34 {}

/// Type derived for production 35
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseAndOp35 {
    bitwise_and_op_0: OwnedToken, /* & */
}

/// Type derived for production 36
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseAndItem36 {
    bitwise_and_op_0: Box<BitwiseAndOp>,
    equality_1: Box<Equality>,
}

/// Type derived for production 37
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Equality37 {
    relational_0: Box<Relational>,
    equality_lst1_1: Box<EqualityLst1>,
}

/// Type derived for production 38
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct EqualityLst1_38 {
    equality_lst1_itm1_0: Box<EqualityLst1Itm1>,
    equality_lst1_1: Box<EqualityLst1>,
}

/// Type derived for production 39
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct EqualityLst1Itm1_39 {
    equality_item_0: Box<EqualityItem>,
}

/// Type derived for production 40
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct EqualityLst1_40 {}

/// Type derived for production 41
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct EqualityItem41 {
    equality_op_0: Box<EqualityOp>,
    relational_1: Box<Relational>,
}

/// Type derived for production 42
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseShiftOp42 {
    bitwise_shift_op_0: OwnedToken, /* <<|>> */
}

/// Type derived for production 43
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Relational43 {
    bitwise_shift_0: Box<BitwiseShift>,
    relational_lst1_1: Box<RelationalLst1>,
}

/// Type derived for production 44
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RelationalLst1_44 {
    relational_lst1_itm1_0: Box<RelationalLst1Itm1>,
    relational_lst1_1: Box<RelationalLst1>,
}

/// Type derived for production 45
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RelationalLst1Itm1_45 {
    relational_item_0: Box<RelationalItem>,
}

/// Type derived for production 46
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RelationalLst1_46 {}

/// Type derived for production 47
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RelationalOp47 {
    relational_op_0: OwnedToken, /* <=|<|>=|> */
}

/// Type derived for production 48
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RelationalItem48 {
    relational_op_0: Box<RelationalOp>,
    bitwise_shift_1: Box<BitwiseShift>,
}

/// Type derived for production 49
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseShift49 {
    summ_0: Box<Summ>,
    bitwise_shift_lst1_1: Box<BitwiseShiftLst1>,
}

/// Type derived for production 50
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseShiftLst1_50 {
    bitwise_shift_lst1_itm1_0: Box<BitwiseShiftLst1Itm1>,
    bitwise_shift_lst1_1: Box<BitwiseShiftLst1>,
}

/// Type derived for production 51
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseShiftLst1Itm1_51 {
    bitwise_shift_item_0: Box<BitwiseShiftItem>,
}

/// Type derived for production 52
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseShiftLst1_52 {}

/// Type derived for production 53
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseShiftItem53 {
    bitwise_shift_op_0: Box<BitwiseShiftOp>,
    summ_1: Box<Summ>,
}

/// Type derived for production 54
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Summ54 {
    mult_0: Box<Mult>,
    summ_lst1_1: Box<SummLst1>,
}

/// Type derived for production 55
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct SummLst1_55 {
    summ_lst1_itm1_0: Box<SummLst1Itm1>,
    summ_lst1_1: Box<SummLst1>,
}

/// Type derived for production 56
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct SummLst1Itm1_56 {
    summ_item_0: Box<SummItem>,
}

/// Type derived for production 57
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct SummLst1_57 {}

/// Type derived for production 58
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Plus58 {
    plus_0: OwnedToken, /* \+ */
}

/// Type derived for production 59
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Minus59 {
    minus_0: OwnedToken, /* - */
}

/// Type derived for production 60
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AddOp60 {
    plus_0: Box<Plus>,
}

/// Type derived for production 61
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AddOp61 {
    minus_0: Box<Minus>,
}

/// Type derived for production 62
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct SummItem62 {
    add_op_0: Box<AddOp>,
    mult_1: Box<Mult>,
}

/// Type derived for production 63
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct PowOp63 {
    pow_op_0: OwnedToken, /* \*\* */
}

/// Type derived for production 64
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Mult64 {
    power_0: Box<Power>,
    mult_lst1_1: Box<MultLst1>,
}

/// Type derived for production 65
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct MultLst1_65 {
    mult_lst1_itm1_0: Box<MultLst1Itm1>,
    mult_lst1_1: Box<MultLst1>,
}

/// Type derived for production 66
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct MultLst1Itm1_66 {
    mult_item_0: Box<MultItem>,
}

/// Type derived for production 67
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct MultLst1_67 {}

/// Type derived for production 68
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct MultOp68 {
    mult_op_0: OwnedToken, /* \*|/|% */
}

/// Type derived for production 69
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct MultItem69 {
    mult_op_0: Box<MultOp>,
    power_1: Box<Power>,
}

/// Type derived for production 70
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Power70 {
    factor_0: Box<Factor>,
    power_lst1_1: Box<PowerLst1>,
}

/// Type derived for production 71
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct PowerLst1_71 {
    power_lst1_itm1_0: Box<PowerLst1Itm1>,
    power_lst1_1: Box<PowerLst1>,
}

/// Type derived for production 72
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct PowerLst1Itm1_72 {
    pow_op_0: Box<PowOp>,
    factor_1: Box<Factor>,
}

/// Type derived for production 73
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct PowerLst1_73 {}

/// Type derived for production 74
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Negate74 {
    minus_0: Box<Minus>,
}

/// Type derived for production 75
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Factor75 {
    number_0: Box<Number>,
}

/// Type derived for production 76
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Factor76 {
    idref_0: Box<Idref>,
}

/// Type derived for production 77
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Factor77 {
    negate_0: Box<Negate>,
    factor_1: Box<Factor>,
}

/// Type derived for production 78
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Factor78 {
    l_paren_0: OwnedToken, /* \( */
    logical_or_1: Box<LogicalOr>,
    r_paren_2: OwnedToken, /* \) */
}

/// Type derived for production 79
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Number79 {
    number_0: OwnedToken, /* 0|[1-9][0-9]* */
}

/// Type derived for production 80
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Idref80 {
    id_0: Box<Id>,
}

/// Type derived for production 81
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Id81 {
    id_0: OwnedToken, /* [a-zA-Z][a-zA-Z0-9]* */
}

//
// Types of non-terminals deduced from the structure of the transformed grammar
//

/// Type derived for non-terminal add_op
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum AddOp {
    AddOp0(Box<AddOp60>),
    AddOp1(Box<AddOp61>),
}

/// Type derived for non-terminal assign_item
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AssignItem {
    id_0: Box<Id>,
    assign_op_1: Box<AssignOp>,
}

/// Type derived for non-terminal assign_op
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AssignOp {
    assign_op_0: OwnedToken, /* (\+|-|\*|/|%|<<|>>|&|\^|\|)?= */
}

/// Type derived for non-terminal assignment
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Assignment {
    assign_item_0: Box<AssignItem>,
    assignment_lst1_1: Box<AssignmentLst1>,
    logical_or_2: Box<LogicalOr>,
}

/// Type derived for non-terminal assignment_lst1
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum AssignmentLst1 {
    AssignmentLst1_0(Box<AssignmentLst1_10>),
    AssignmentLst1_1(Box<AssignmentLst1_12>),
}

/// Type derived for non-terminal assignment_lst1_itm1
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AssignmentLst1Itm1 {
    assign_item_0: Box<AssignItem>,
}

/// Type derived for non-terminal bitwise_and
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseAnd {
    equality_0: Box<Equality>,
    bitwise_and_lst1_1: Box<BitwiseAndLst1>,
}

/// Type derived for non-terminal bitwise_and_item
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseAndItem {
    bitwise_and_op_0: Box<BitwiseAndOp>,
    equality_1: Box<Equality>,
}

/// Type derived for non-terminal bitwise_and_lst1
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum BitwiseAndLst1 {
    BitwiseAndLst1_0(Box<BitwiseAndLst1_32>),
    BitwiseAndLst1_1(Box<BitwiseAndLst1_34>),
}

/// Type derived for non-terminal bitwise_and_lst1_itm1
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseAndLst1Itm1 {
    bitwise_and_item_0: Box<BitwiseAndItem>,
}

/// Type derived for non-terminal bitwise_and_op
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseAndOp {
    bitwise_and_op_0: OwnedToken, /* & */
}

/// Type derived for non-terminal bitwise_or
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseOr {
    bitwise_and_0: Box<BitwiseAnd>,
    bitwise_or_lst1_1: Box<BitwiseOrLst1>,
}

/// Type derived for non-terminal bitwise_or_item
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseOrItem {
    bitwise_or_op_0: Box<BitwiseOrOp>,
    bitwise_and_1: Box<BitwiseAnd>,
}

/// Type derived for non-terminal bitwise_or_lst1
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum BitwiseOrLst1 {
    BitwiseOrLst1_0(Box<BitwiseOrLst1_26>),
    BitwiseOrLst1_1(Box<BitwiseOrLst1_28>),
}

/// Type derived for non-terminal bitwise_or_lst1_itm1
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseOrLst1Itm1 {
    bitwise_or_item_0: Box<BitwiseOrItem>,
}

/// Type derived for non-terminal bitwise_or_op
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseOrOp {
    bitwise_or_op_0: OwnedToken, /* \| */
}

/// Type derived for non-terminal bitwise_shift
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseShift {
    summ_0: Box<Summ>,
    bitwise_shift_lst1_1: Box<BitwiseShiftLst1>,
}

/// Type derived for non-terminal bitwise_shift_item
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseShiftItem {
    bitwise_shift_op_0: Box<BitwiseShiftOp>,
    summ_1: Box<Summ>,
}

/// Type derived for non-terminal bitwise_shift_lst1
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum BitwiseShiftLst1 {
    BitwiseShiftLst1_0(Box<BitwiseShiftLst1_50>),
    BitwiseShiftLst1_1(Box<BitwiseShiftLst1_52>),
}

/// Type derived for non-terminal bitwise_shift_lst1_itm1
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseShiftLst1Itm1 {
    bitwise_shift_item_0: Box<BitwiseShiftItem>,
}

/// Type derived for non-terminal bitwise_shift_op
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BitwiseShiftOp {
    bitwise_shift_op_0: OwnedToken, /* <<|>> */
}

/// Type derived for non-terminal calc
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Calc {
    calc_lst1_0: Box<CalcLst1>,
}

/// Type derived for non-terminal calc_lst1
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum CalcLst1 {
    CalcLst1_0(Box<CalcLst1_1>),
    CalcLst1_1(Box<CalcLst1_3>),
}

/// Type derived for non-terminal calc_lst1_itm1
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct CalcLst1Itm1 {
    instruction_0: Box<Instruction>,
    semicolon_1: OwnedToken, /* ; */
}

/// Type derived for non-terminal equality
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Equality {
    relational_0: Box<Relational>,
    equality_lst1_1: Box<EqualityLst1>,
}

/// Type derived for non-terminal equality_item
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct EqualityItem {
    equality_op_0: Box<EqualityOp>,
    relational_1: Box<Relational>,
}

/// Type derived for non-terminal equality_lst1
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum EqualityLst1 {
    EqualityLst1_0(Box<EqualityLst1_38>),
    EqualityLst1_1(Box<EqualityLst1_40>),
}

/// Type derived for non-terminal equality_lst1_itm1
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct EqualityLst1Itm1 {
    equality_item_0: Box<EqualityItem>,
}

/// Type derived for non-terminal equality_op
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct EqualityOp {
    equality_op_0: OwnedToken, /* ==|!= */
}

/// Type derived for non-terminal factor
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum Factor {
    Factor0(Box<Factor75>),
    Factor1(Box<Factor76>),
    Factor2(Box<Factor77>),
    Factor3(Box<Factor78>),
}

/// Type derived for non-terminal id
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Id {
    id_0: OwnedToken, /* [a-zA-Z][a-zA-Z0-9]* */
}

/// Type derived for non-terminal idref
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Idref {
    id_0: Box<Id>,
}

/// Type derived for non-terminal instruction
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum Instruction {
    Instruction0(Box<Instruction4>),
    Instruction1(Box<Instruction5>),
}

/// Type derived for non-terminal logical_and
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalAnd {
    bitwise_or_0: Box<BitwiseOr>,
    logical_and_lst1_1: Box<LogicalAndLst1>,
}

/// Type derived for non-terminal logical_and_item
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalAndItem {
    logical_and_op_0: Box<LogicalAndOp>,
    bitwise_or_1: Box<BitwiseOr>,
}

/// Type derived for non-terminal logical_and_lst1
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum LogicalAndLst1 {
    LogicalAndLst1_0(Box<LogicalAndLst1_20>),
    LogicalAndLst1_1(Box<LogicalAndLst1_22>),
}

/// Type derived for non-terminal logical_and_lst1_itm1
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalAndLst1Itm1 {
    logical_and_item_0: Box<LogicalAndItem>,
}

/// Type derived for non-terminal logical_and_op
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalAndOp {
    logical_and_op_0: OwnedToken, /* && */
}

/// Type derived for non-terminal logical_or
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalOr {
    logical_and_0: Box<LogicalAnd>,
    logical_or_lst1_1: Box<LogicalOrLst1>,
}

/// Type derived for non-terminal logical_or_item
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalOrItem {
    logical_or_op_0: Box<LogicalOrOp>,
    logical_and_1: Box<LogicalAnd>,
}

/// Type derived for non-terminal logical_or_lst1
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum LogicalOrLst1 {
    LogicalOrLst1_0(Box<LogicalOrLst1_14>),
    LogicalOrLst1_1(Box<LogicalOrLst1_16>),
}

/// Type derived for non-terminal logical_or_lst1_itm1
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalOrLst1Itm1 {
    logical_or_item_0: Box<LogicalOrItem>,
}

/// Type derived for non-terminal logical_or_op
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LogicalOrOp {
    logical_or_op_0: OwnedToken, /* \|\| */
}

/// Type derived for non-terminal minus
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Minus {
    minus_0: OwnedToken, /* - */
}

/// Type derived for non-terminal mult
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Mult {
    power_0: Box<Power>,
    mult_lst1_1: Box<MultLst1>,
}

/// Type derived for non-terminal mult_item
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct MultItem {
    mult_op_0: Box<MultOp>,
    power_1: Box<Power>,
}

/// Type derived for non-terminal mult_lst1
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum MultLst1 {
    MultLst1_0(Box<MultLst1_65>),
    MultLst1_1(Box<MultLst1_67>),
}

/// Type derived for non-terminal mult_lst1_itm1
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct MultLst1Itm1 {
    mult_item_0: Box<MultItem>,
}

/// Type derived for non-terminal mult_op
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct MultOp {
    mult_op_0: OwnedToken, /* \*|/|% */
}

/// Type derived for non-terminal negate
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Negate {
    minus_0: Box<Minus>,
}

/// Type derived for non-terminal number
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Number {
    number_0: OwnedToken, /* 0|[1-9][0-9]* */
}

/// Type derived for non-terminal plus
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Plus {
    plus_0: OwnedToken, /* \+ */
}

/// Type derived for non-terminal pow_op
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct PowOp {
    pow_op_0: OwnedToken, /* \*\* */
}

/// Type derived for non-terminal power
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Power {
    factor_0: Box<Factor>,
    power_lst1_1: Box<PowerLst1>,
}

/// Type derived for non-terminal power_lst1
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum PowerLst1 {
    PowerLst1_0(Box<PowerLst1_71>),
    PowerLst1_1(Box<PowerLst1_73>),
}

/// Type derived for non-terminal power_lst1_itm1
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct PowerLst1Itm1 {
    pow_op_0: Box<PowOp>,
    factor_1: Box<Factor>,
}

/// Type derived for non-terminal relational
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Relational {
    bitwise_shift_0: Box<BitwiseShift>,
    relational_lst1_1: Box<RelationalLst1>,
}

/// Type derived for non-terminal relational_item
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RelationalItem {
    relational_op_0: Box<RelationalOp>,
    bitwise_shift_1: Box<BitwiseShift>,
}

/// Type derived for non-terminal relational_lst1
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum RelationalLst1 {
    RelationalLst1_0(Box<RelationalLst1_44>),
    RelationalLst1_1(Box<RelationalLst1_46>),
}

/// Type derived for non-terminal relational_lst1_itm1
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RelationalLst1Itm1 {
    relational_item_0: Box<RelationalItem>,
}

/// Type derived for non-terminal relational_op
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RelationalOp {
    relational_op_0: OwnedToken, /* <=|<|>=|> */
}

/// Type derived for non-terminal summ
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Summ {
    mult_0: Box<Mult>,
    summ_lst1_1: Box<SummLst1>,
}

/// Type derived for non-terminal summ_item
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct SummItem {
    add_op_0: Box<AddOp>,
    mult_1: Box<Mult>,
}

/// Type derived for non-terminal summ_lst1
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum SummLst1 {
    SummLst1_0(Box<SummLst1_55>),
    SummLst1_1(Box<SummLst1_57>),
}

/// Type derived for non-terminal summ_lst1_itm1
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct SummLst1Itm1 {
    summ_item_0: Box<SummItem>,
}

///
/// The `CalcGrammarTrait` trait is automatically generated for the
/// given grammar.
/// All functions have default implementations.
///
pub trait CalcGrammarTrait {
    ///
    /// Implement this method if you need the provided information
    ///
    fn init(&mut self, _file_name: &std::path::Path) {}

    /// Semantic action for production 0:
    ///
    /// calc: calc_lst1;
    ///
    fn calc_0(
        &mut self,
        _calc_lst1_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// calc_lst1: calc_lst1_itm1 calc_lst1;
    ///
    fn calc_lst1_1(
        &mut self,
        _calc_lst1_itm1_0: &ParseTreeStackEntry,
        _calc_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// calc_lst1_itm1: instruction ";";
    ///
    fn calc_lst1_itm1_2(
        &mut self,
        _instruction_0: &ParseTreeStackEntry,
        _semicolon_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// calc_lst1: ;
    ///
    fn calc_lst1_3(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// instruction: assignment;
    ///
    fn instruction_4(
        &mut self,
        _assignment_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// instruction: logical_or;
    ///
    fn instruction_5(
        &mut self,
        _logical_or_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// equality_op: "==|!=";
    ///
    fn equality_op_6(
        &mut self,
        _equality_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// assign_op: "(\+|-|\*|/|%|<<|>>|&|\^|\|)?=";
    ///
    fn assign_op_7(
        &mut self,
        _assign_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// assign_item: id assign_op;
    ///
    fn assign_item_8(
        &mut self,
        _id_0: &ParseTreeStackEntry,
        _assign_op_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// assignment: assign_item assignment_lst1 logical_or;
    ///
    fn assignment_9(
        &mut self,
        _assign_item_0: &ParseTreeStackEntry,
        _assignment_lst1_1: &ParseTreeStackEntry,
        _logical_or_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// assignment_lst1: assignment_lst1_itm1 assignment_lst1;
    ///
    fn assignment_lst1_10(
        &mut self,
        _assignment_lst1_itm1_0: &ParseTreeStackEntry,
        _assignment_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// assignment_lst1_itm1: assign_item;
    ///
    fn assignment_lst1_itm1_11(
        &mut self,
        _assign_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// assignment_lst1: ;
    ///
    fn assignment_lst1_12(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// logical_or: logical_and logical_or_lst1;
    ///
    fn logical_or_13(
        &mut self,
        _logical_and_0: &ParseTreeStackEntry,
        _logical_or_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// logical_or_lst1: logical_or_lst1_itm1 logical_or_lst1;
    ///
    fn logical_or_lst1_14(
        &mut self,
        _logical_or_lst1_itm1_0: &ParseTreeStackEntry,
        _logical_or_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// logical_or_lst1_itm1: logical_or_item;
    ///
    fn logical_or_lst1_itm1_15(
        &mut self,
        _logical_or_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// logical_or_lst1: ;
    ///
    fn logical_or_lst1_16(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// logical_or_op: "\|\|";
    ///
    fn logical_or_op_17(
        &mut self,
        _logical_or_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// logical_or_item: logical_or_op logical_and;
    ///
    fn logical_or_item_18(
        &mut self,
        _logical_or_op_0: &ParseTreeStackEntry,
        _logical_and_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// logical_and: bitwise_or logical_and_lst1;
    ///
    fn logical_and_19(
        &mut self,
        _bitwise_or_0: &ParseTreeStackEntry,
        _logical_and_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// logical_and_lst1: logical_and_lst1_itm1 logical_and_lst1;
    ///
    fn logical_and_lst1_20(
        &mut self,
        _logical_and_lst1_itm1_0: &ParseTreeStackEntry,
        _logical_and_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// logical_and_lst1_itm1: logical_and_item;
    ///
    fn logical_and_lst1_itm1_21(
        &mut self,
        _logical_and_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// logical_and_lst1: ;
    ///
    fn logical_and_lst1_22(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// logical_and_op: "&&";
    ///
    fn logical_and_op_23(
        &mut self,
        _logical_and_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// logical_and_item: logical_and_op bitwise_or;
    ///
    fn logical_and_item_24(
        &mut self,
        _logical_and_op_0: &ParseTreeStackEntry,
        _bitwise_or_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// bitwise_or: bitwise_and bitwise_or_lst1;
    ///
    fn bitwise_or_25(
        &mut self,
        _bitwise_and_0: &ParseTreeStackEntry,
        _bitwise_or_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// bitwise_or_lst1: bitwise_or_lst1_itm1 bitwise_or_lst1;
    ///
    fn bitwise_or_lst1_26(
        &mut self,
        _bitwise_or_lst1_itm1_0: &ParseTreeStackEntry,
        _bitwise_or_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// bitwise_or_lst1_itm1: bitwise_or_item;
    ///
    fn bitwise_or_lst1_itm1_27(
        &mut self,
        _bitwise_or_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// bitwise_or_lst1: ;
    ///
    fn bitwise_or_lst1_28(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// bitwise_or_op: "\|";
    ///
    fn bitwise_or_op_29(
        &mut self,
        _bitwise_or_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// bitwise_or_item: bitwise_or_op bitwise_and;
    ///
    fn bitwise_or_item_30(
        &mut self,
        _bitwise_or_op_0: &ParseTreeStackEntry,
        _bitwise_and_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// bitwise_and: equality bitwise_and_lst1;
    ///
    fn bitwise_and_31(
        &mut self,
        _equality_0: &ParseTreeStackEntry,
        _bitwise_and_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// bitwise_and_lst1: bitwise_and_lst1_itm1 bitwise_and_lst1;
    ///
    fn bitwise_and_lst1_32(
        &mut self,
        _bitwise_and_lst1_itm1_0: &ParseTreeStackEntry,
        _bitwise_and_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// bitwise_and_lst1_itm1: bitwise_and_item;
    ///
    fn bitwise_and_lst1_itm1_33(
        &mut self,
        _bitwise_and_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// bitwise_and_lst1: ;
    ///
    fn bitwise_and_lst1_34(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// bitwise_and_op: "&";
    ///
    fn bitwise_and_op_35(
        &mut self,
        _bitwise_and_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// bitwise_and_item: bitwise_and_op equality;
    ///
    fn bitwise_and_item_36(
        &mut self,
        _bitwise_and_op_0: &ParseTreeStackEntry,
        _equality_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// equality: relational equality_lst1;
    ///
    fn equality_37(
        &mut self,
        _relational_0: &ParseTreeStackEntry,
        _equality_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// equality_lst1: equality_lst1_itm1 equality_lst1;
    ///
    fn equality_lst1_38(
        &mut self,
        _equality_lst1_itm1_0: &ParseTreeStackEntry,
        _equality_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// equality_lst1_itm1: equality_item;
    ///
    fn equality_lst1_itm1_39(
        &mut self,
        _equality_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// equality_lst1: ;
    ///
    fn equality_lst1_40(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// equality_item: equality_op relational;
    ///
    fn equality_item_41(
        &mut self,
        _equality_op_0: &ParseTreeStackEntry,
        _relational_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// bitwise_shift_op: "<<|>>";
    ///
    fn bitwise_shift_op_42(
        &mut self,
        _bitwise_shift_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// relational: bitwise_shift relational_lst1;
    ///
    fn relational_43(
        &mut self,
        _bitwise_shift_0: &ParseTreeStackEntry,
        _relational_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// relational_lst1: relational_lst1_itm1 relational_lst1;
    ///
    fn relational_lst1_44(
        &mut self,
        _relational_lst1_itm1_0: &ParseTreeStackEntry,
        _relational_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// relational_lst1_itm1: relational_item;
    ///
    fn relational_lst1_itm1_45(
        &mut self,
        _relational_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// relational_lst1: ;
    ///
    fn relational_lst1_46(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// relational_op: "<=|<|>=|>";
    ///
    fn relational_op_47(
        &mut self,
        _relational_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// relational_item: relational_op bitwise_shift;
    ///
    fn relational_item_48(
        &mut self,
        _relational_op_0: &ParseTreeStackEntry,
        _bitwise_shift_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// bitwise_shift: summ bitwise_shift_lst1;
    ///
    fn bitwise_shift_49(
        &mut self,
        _summ_0: &ParseTreeStackEntry,
        _bitwise_shift_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// bitwise_shift_lst1: bitwise_shift_lst1_itm1 bitwise_shift_lst1;
    ///
    fn bitwise_shift_lst1_50(
        &mut self,
        _bitwise_shift_lst1_itm1_0: &ParseTreeStackEntry,
        _bitwise_shift_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// bitwise_shift_lst1_itm1: bitwise_shift_item;
    ///
    fn bitwise_shift_lst1_itm1_51(
        &mut self,
        _bitwise_shift_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// bitwise_shift_lst1: ;
    ///
    fn bitwise_shift_lst1_52(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// bitwise_shift_item: bitwise_shift_op summ;
    ///
    fn bitwise_shift_item_53(
        &mut self,
        _bitwise_shift_op_0: &ParseTreeStackEntry,
        _summ_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// summ: mult summ_lst1;
    ///
    fn summ_54(
        &mut self,
        _mult_0: &ParseTreeStackEntry,
        _summ_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// summ_lst1: summ_lst1_itm1 summ_lst1;
    ///
    fn summ_lst1_55(
        &mut self,
        _summ_lst1_itm1_0: &ParseTreeStackEntry,
        _summ_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// summ_lst1_itm1: summ_item;
    ///
    fn summ_lst1_itm1_56(
        &mut self,
        _summ_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// summ_lst1: ;
    ///
    fn summ_lst1_57(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// plus: "\+";
    ///
    fn plus_58(
        &mut self,
        _plus_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// minus: "-";
    ///
    fn minus_59(
        &mut self,
        _minus_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// add_op: plus;
    ///
    fn add_op_60(
        &mut self,
        _plus_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// add_op: minus;
    ///
    fn add_op_61(
        &mut self,
        _minus_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// summ_item: add_op mult;
    ///
    fn summ_item_62(
        &mut self,
        _add_op_0: &ParseTreeStackEntry,
        _mult_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// pow_op: "\*\*";
    ///
    fn pow_op_63(
        &mut self,
        _pow_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// mult: power mult_lst1;
    ///
    fn mult_64(
        &mut self,
        _power_0: &ParseTreeStackEntry,
        _mult_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// mult_lst1: mult_lst1_itm1 mult_lst1;
    ///
    fn mult_lst1_65(
        &mut self,
        _mult_lst1_itm1_0: &ParseTreeStackEntry,
        _mult_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// mult_lst1_itm1: mult_item;
    ///
    fn mult_lst1_itm1_66(
        &mut self,
        _mult_item_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// mult_lst1: ;
    ///
    fn mult_lst1_67(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// mult_op: "\*|/|%";
    ///
    fn mult_op_68(
        &mut self,
        _mult_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// mult_item: mult_op power;
    ///
    fn mult_item_69(
        &mut self,
        _mult_op_0: &ParseTreeStackEntry,
        _power_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// power: factor power_lst1;
    ///
    fn power_70(
        &mut self,
        _factor_0: &ParseTreeStackEntry,
        _power_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// power_lst1: power_lst1_itm1 power_lst1;
    ///
    fn power_lst1_71(
        &mut self,
        _power_lst1_itm1_0: &ParseTreeStackEntry,
        _power_lst1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// power_lst1_itm1: pow_op factor;
    ///
    fn power_lst1_itm1_72(
        &mut self,
        _pow_op_0: &ParseTreeStackEntry,
        _factor_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// power_lst1: ;
    ///
    fn power_lst1_73(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// negate: minus;
    ///
    fn negate_74(
        &mut self,
        _minus_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// factor: number;
    ///
    fn factor_75(
        &mut self,
        _number_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// factor: idref;
    ///
    fn factor_76(
        &mut self,
        _idref_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// factor: negate factor;
    ///
    fn factor_77(
        &mut self,
        _negate_0: &ParseTreeStackEntry,
        _factor_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// factor: "\(" logical_or "\)";
    ///
    fn factor_78(
        &mut self,
        _l_paren_0: &ParseTreeStackEntry,
        _logical_or_1: &ParseTreeStackEntry,
        _r_paren_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// number: "0|[1-9][0-9]*";
    ///
    fn number_79(
        &mut self,
        _number_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// idref: id;
    ///
    fn idref_80(
        &mut self,
        _id_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// id: "[a-zA-Z_][a-zA-Z0-9_]*";
    ///
    fn id_81(
        &mut self,
        _id_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }
}

impl UserActionsTrait for CalcGrammar {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// Is is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &std::path::Path) {
        CalcGrammarTrait::init(self, file_name);
    }

    ///
    /// This function is implemented automatically for the user's item CalcGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry],
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        match prod_num {
            0 => self.calc_0(&children[0], parse_tree),

            1 => self.calc_lst1_1(&children[0], &children[1], parse_tree),

            2 => self.calc_lst1_itm1_2(&children[0], &children[1], parse_tree),

            3 => self.calc_lst1_3(parse_tree),

            4 => self.instruction_4(&children[0], parse_tree),

            5 => self.instruction_5(&children[0], parse_tree),

            6 => self.equality_op_6(&children[0], parse_tree),

            7 => self.assign_op_7(&children[0], parse_tree),

            8 => self.assign_item_8(&children[0], &children[1], parse_tree),

            9 => self.assignment_9(&children[0], &children[1], &children[2], parse_tree),

            10 => self.assignment_lst1_10(&children[0], &children[1], parse_tree),

            11 => self.assignment_lst1_itm1_11(&children[0], parse_tree),

            12 => self.assignment_lst1_12(parse_tree),

            13 => self.logical_or_13(&children[0], &children[1], parse_tree),

            14 => self.logical_or_lst1_14(&children[0], &children[1], parse_tree),

            15 => self.logical_or_lst1_itm1_15(&children[0], parse_tree),

            16 => self.logical_or_lst1_16(parse_tree),

            17 => self.logical_or_op_17(&children[0], parse_tree),

            18 => self.logical_or_item_18(&children[0], &children[1], parse_tree),

            19 => self.logical_and_19(&children[0], &children[1], parse_tree),

            20 => self.logical_and_lst1_20(&children[0], &children[1], parse_tree),

            21 => self.logical_and_lst1_itm1_21(&children[0], parse_tree),

            22 => self.logical_and_lst1_22(parse_tree),

            23 => self.logical_and_op_23(&children[0], parse_tree),

            24 => self.logical_and_item_24(&children[0], &children[1], parse_tree),

            25 => self.bitwise_or_25(&children[0], &children[1], parse_tree),

            26 => self.bitwise_or_lst1_26(&children[0], &children[1], parse_tree),

            27 => self.bitwise_or_lst1_itm1_27(&children[0], parse_tree),

            28 => self.bitwise_or_lst1_28(parse_tree),

            29 => self.bitwise_or_op_29(&children[0], parse_tree),

            30 => self.bitwise_or_item_30(&children[0], &children[1], parse_tree),

            31 => self.bitwise_and_31(&children[0], &children[1], parse_tree),

            32 => self.bitwise_and_lst1_32(&children[0], &children[1], parse_tree),

            33 => self.bitwise_and_lst1_itm1_33(&children[0], parse_tree),

            34 => self.bitwise_and_lst1_34(parse_tree),

            35 => self.bitwise_and_op_35(&children[0], parse_tree),

            36 => self.bitwise_and_item_36(&children[0], &children[1], parse_tree),

            37 => self.equality_37(&children[0], &children[1], parse_tree),

            38 => self.equality_lst1_38(&children[0], &children[1], parse_tree),

            39 => self.equality_lst1_itm1_39(&children[0], parse_tree),

            40 => self.equality_lst1_40(parse_tree),

            41 => self.equality_item_41(&children[0], &children[1], parse_tree),

            42 => self.bitwise_shift_op_42(&children[0], parse_tree),

            43 => self.relational_43(&children[0], &children[1], parse_tree),

            44 => self.relational_lst1_44(&children[0], &children[1], parse_tree),

            45 => self.relational_lst1_itm1_45(&children[0], parse_tree),

            46 => self.relational_lst1_46(parse_tree),

            47 => self.relational_op_47(&children[0], parse_tree),

            48 => self.relational_item_48(&children[0], &children[1], parse_tree),

            49 => self.bitwise_shift_49(&children[0], &children[1], parse_tree),

            50 => self.bitwise_shift_lst1_50(&children[0], &children[1], parse_tree),

            51 => self.bitwise_shift_lst1_itm1_51(&children[0], parse_tree),

            52 => self.bitwise_shift_lst1_52(parse_tree),

            53 => self.bitwise_shift_item_53(&children[0], &children[1], parse_tree),

            54 => self.summ_54(&children[0], &children[1], parse_tree),

            55 => self.summ_lst1_55(&children[0], &children[1], parse_tree),

            56 => self.summ_lst1_itm1_56(&children[0], parse_tree),

            57 => self.summ_lst1_57(parse_tree),

            58 => self.plus_58(&children[0], parse_tree),

            59 => self.minus_59(&children[0], parse_tree),

            60 => self.add_op_60(&children[0], parse_tree),

            61 => self.add_op_61(&children[0], parse_tree),

            62 => self.summ_item_62(&children[0], &children[1], parse_tree),

            63 => self.pow_op_63(&children[0], parse_tree),

            64 => self.mult_64(&children[0], &children[1], parse_tree),

            65 => self.mult_lst1_65(&children[0], &children[1], parse_tree),

            66 => self.mult_lst1_itm1_66(&children[0], parse_tree),

            67 => self.mult_lst1_67(parse_tree),

            68 => self.mult_op_68(&children[0], parse_tree),

            69 => self.mult_item_69(&children[0], &children[1], parse_tree),

            70 => self.power_70(&children[0], &children[1], parse_tree),

            71 => self.power_lst1_71(&children[0], &children[1], parse_tree),

            72 => self.power_lst1_itm1_72(&children[0], &children[1], parse_tree),

            73 => self.power_lst1_73(parse_tree),

            74 => self.negate_74(&children[0], parse_tree),

            75 => self.factor_75(&children[0], parse_tree),

            76 => self.factor_76(&children[0], parse_tree),

            77 => self.factor_77(&children[0], &children[1], parse_tree),

            78 => self.factor_78(&children[0], &children[1], &children[2], parse_tree),

            79 => self.number_79(&children[0], parse_tree),

            80 => self.idref_80(&children[0], parse_tree),

            81 => self.id_81(&children[0], parse_tree),

            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
