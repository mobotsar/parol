// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use crate::boolean_grammar::BooleanGrammar;
use id_tree::Tree;
use miette::{miette, Result};
use parol_runtime::lexer::OwnedToken;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

//
// Output Types of productions deduced from the structure of the transformed grammar
//

/// Type derived for production 0
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Expressions0 {
    expression_0: Box<Expression>,
    expressions_list_1: Box<ExpressionsList>,
    expressions_suffix_2: Box<ExpressionsSuffix>,
}

/// Type derived for production 1
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ExpressionsSuffix1 {
    opt: Option<Box<ExpressionsOpt>>,
}

/// Type derived for production 2
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ExpressionsSuffix2 {
    opt: Option<Box<ExpressionsOpt>>,
}

/// Type derived for production 3
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ExpressionsOpt3 {
    semicolon_0: Box<Semicolon>,
}

/// Type derived for production 6
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Expression6 {
    term_0: Box<Term>,
    tail_expression_1: Box<TailExpression>,
}

/// Type derived for production 7
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct TailExpression7 {
    tail_expression_list_0: Box<TailExpressionList>,
}

/// Type derived for production 10
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Term10 {
    term_opt_0: Box<TermOpt>,
    factor_1: Box<Factor>,
}

/// Type derived for production 11
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Term11 {
    factor_0: (),
}

/// Type derived for production 12
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct TermOpt12 {
    unary_operator_0: Box<UnaryOperator>,
}

/// Type derived for production 13
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Boolean13 {
    true_0: Box<True>,
}

/// Type derived for production 14
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Boolean14 {
    false_0: Box<False>,
}

/// Type derived for production 15
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct UnaryOperator15 {
    not_0: Box<Not>,
}

/// Type derived for production 16
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BinaryOperator16 {
    and_op_0: Box<AndOp>,
}

/// Type derived for production 17
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BinaryOperator17 {
    or_op_0: Box<OrOp>,
}

/// Type derived for production 18
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BinaryOperator18 {
    xor_op_0: Box<XorOp>,
}

/// Type derived for production 19
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BinaryOperator19 {
    nor_op_0: Box<NorOp>,
}

/// Type derived for production 20
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BinaryOperator20 {
    nand_op_0: Box<NandOp>,
}

/// Type derived for production 21
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BinaryOperator21 {
    xnor_op_0: Box<XnorOp>,
}

/// Type derived for production 22
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AndOp22 {
    and_op_0: OwnedToken, /* (?i)AND */
}

/// Type derived for production 23
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct OrOp23 {
    or_op_0: OwnedToken, /* (?i)OR */
}

/// Type derived for production 24
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct XorOp24 {
    xor_op_0: OwnedToken, /* (?i)XOR */
}

/// Type derived for production 25
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct NorOp25 {
    nor_op_0: OwnedToken, /* (?i)NOR */
}

/// Type derived for production 26
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct NandOp26 {
    nand_op_0: OwnedToken, /* (?i)NAND */
}

/// Type derived for production 27
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct XnorOp27 {
    xnor_op_0: OwnedToken, /* (?i)XNOR */
}

/// Type derived for production 28
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct True28 {
    true_0: OwnedToken, /* (?i)TRUE */
}

/// Type derived for production 29
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct False29 {
    false_0: OwnedToken, /* (?i)FALSE */
}

/// Type derived for production 30
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Not30 {
    not_0: OwnedToken, /* (?i)NOT */
}

/// Type derived for production 31
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Parenthesized31 {
    left_parenthesis_0: Box<LeftParenthesis>,
    expression_1: Box<Expression>,
    right_parenthesis_2: Box<RightParenthesis>,
}

/// Type derived for production 32
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Semicolon32 {
    semicolon_0: OwnedToken, /* ; */
}

/// Type derived for production 33
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LeftParenthesis33 {
    left_parenthesis_0: OwnedToken, /* \( */
}

/// Type derived for production 34
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RightParenthesis34 {
    right_parenthesis_0: OwnedToken, /* \) */
}

/// Type derived for production 35
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Factor35 {
    boolean_0: Box<Boolean>,
}

/// Type derived for production 36
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Factor36 {
    parenthesized_0: Box<Parenthesized>,
}

//
// Types of non-terminals deduced from the structure of the transformed grammar
//

/// Type derived for non-terminal AndOp
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AndOp {
    and_op_0: OwnedToken, /* (?i)AND */
}

/// Type derived for non-terminal BinaryOperator
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum BinaryOperator {
    BinaryOperator0(Box<BinaryOperator16>),
    BinaryOperator1(Box<BinaryOperator17>),
    BinaryOperator2(Box<BinaryOperator18>),
    BinaryOperator3(Box<BinaryOperator19>),
    BinaryOperator4(Box<BinaryOperator20>),
    BinaryOperator5(Box<BinaryOperator21>),
}

/// Type derived for non-terminal Boolean
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum Boolean {
    Boolean0(Box<Boolean13>),
    Boolean1(Box<Boolean14>),
}

/// Type derived for non-terminal Expression
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Expression {
    term_0: Box<Term>,
    tail_expression_1: Box<TailExpression>,
}

/// Type derived for non-terminal Expressions
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Expressions {
    expression_0: Box<Expression>,
    expressions_list_1: Box<ExpressionsList>,
    expressions_suffix_2: Box<ExpressionsSuffix>,
}

/// Type derived for non-terminal ExpressionsList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ExpressionsList {
    vec: Vec<(Semicolon, Expression)>,
}

/// Type derived for non-terminal ExpressionsOpt
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ExpressionsOpt {
    semicolon_0: Box<Semicolon>,
}

/// Type derived for non-terminal ExpressionsSuffix
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ExpressionsSuffix {
    opt: Option<Box<ExpressionsOpt>>,
}

/// Type derived for non-terminal Factor
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum Factor {
    Factor0(Box<Factor35>),
    Factor1(Box<Factor36>),
}

/// Type derived for non-terminal False
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct False {
    false_0: OwnedToken, /* (?i)FALSE */
}

/// Type derived for non-terminal LeftParenthesis
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct LeftParenthesis {
    left_parenthesis_0: OwnedToken, /* \( */
}

/// Type derived for non-terminal NandOp
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct NandOp {
    nand_op_0: OwnedToken, /* (?i)NAND */
}

/// Type derived for non-terminal NorOp
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct NorOp {
    nor_op_0: OwnedToken, /* (?i)NOR */
}

/// Type derived for non-terminal Not
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Not {
    not_0: OwnedToken, /* (?i)NOT */
}

/// Type derived for non-terminal OrOp
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct OrOp {
    or_op_0: OwnedToken, /* (?i)OR */
}

/// Type derived for non-terminal Parenthesized
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Parenthesized {
    left_parenthesis_0: Box<LeftParenthesis>,
    expression_1: Box<Expression>,
    right_parenthesis_2: Box<RightParenthesis>,
}

/// Type derived for non-terminal RightParenthesis
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RightParenthesis {
    right_parenthesis_0: OwnedToken, /* \) */
}

/// Type derived for non-terminal Semicolon
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Semicolon {
    semicolon_0: OwnedToken, /* ; */
}

/// Type derived for non-terminal TailExpression
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct TailExpression {
    tail_expression_list_0: Box<TailExpressionList>,
}

/// Type derived for non-terminal TailExpressionList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct TailExpressionList {
    vec: Vec<(BinaryOperator, Term)>,
}

/// Type derived for non-terminal Term
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum Term {
    Term0(Box<Term10>),
    Term1(Box<Term11>),
}

/// Type derived for non-terminal TermOpt
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct TermOpt {
    unary_operator_0: Box<UnaryOperator>,
}

/// Type derived for non-terminal True
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct True {
    true_0: OwnedToken, /* (?i)TRUE */
}

/// Type derived for non-terminal UnaryOperator
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct UnaryOperator {
    not_0: Box<Not>,
}

/// Type derived for non-terminal XnorOp
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct XnorOp {
    xnor_op_0: OwnedToken, /* (?i)XNOR */
}

/// Type derived for non-terminal XorOp
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct XorOp {
    xor_op_0: OwnedToken, /* (?i)XOR */
}

///
/// The `BooleanGrammarTrait` trait is automatically generated for the
/// given grammar.
/// All functions have default implementations.
///
pub trait BooleanGrammarTrait {
    ///
    /// Implement this method if you need the provided information
    ///
    fn init(&mut self, _file_name: &std::path::Path) {}

    /// Semantic action for production 0:
    ///
    /// Expressions: Expression ExpressionsList ExpressionsSuffix;
    ///
    fn expressions_0(
        &mut self,
        _expression_0: &ParseTreeStackEntry,
        _expressions_list_1: &ParseTreeStackEntry,
        _expressions_suffix_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// ExpressionsSuffix: ExpressionsOpt;
    ///
    fn expressions_suffix_1(
        &mut self,
        _expressions_opt_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// ExpressionsSuffix: /* Option<ExpressionsOpt>::None */;
    ///
    fn expressions_suffix_2(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// ExpressionsOpt: Semicolon;
    ///
    fn expressions_opt_3(
        &mut self,
        _semicolon_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// ExpressionsList: Semicolon Expression ExpressionsList;
    ///
    fn expressions_list_4(
        &mut self,
        _semicolon_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _expressions_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// ExpressionsList: /* Vec<ExpressionsList>::New */;
    ///
    fn expressions_list_5(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// Expression: Term TailExpression;
    ///
    fn expression_6(
        &mut self,
        _term_0: &ParseTreeStackEntry,
        _tail_expression_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// TailExpression: TailExpressionList;
    ///
    fn tail_expression_7(
        &mut self,
        _tail_expression_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// TailExpressionList: BinaryOperator Term TailExpressionList;
    ///
    fn tail_expression_list_8(
        &mut self,
        _binary_operator_0: &ParseTreeStackEntry,
        _term_1: &ParseTreeStackEntry,
        _tail_expression_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// TailExpressionList: /* Vec<TailExpressionList>::New */;
    ///
    fn tail_expression_list_9(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// Term: TermOpt Factor;
    ///
    fn term_10(
        &mut self,
        _term_opt_0: &ParseTreeStackEntry,
        _factor_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// Term: /* Option<TermOpt>::None */ Factor;
    ///
    fn term_11(
        &mut self,
        _factor_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// TermOpt: UnaryOperator;
    ///
    fn term_opt_12(
        &mut self,
        _unary_operator_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// Boolean: True;
    ///
    fn boolean_13(
        &mut self,
        _true_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// Boolean: False;
    ///
    fn boolean_14(
        &mut self,
        _false_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// UnaryOperator: Not;
    ///
    fn unary_operator_15(
        &mut self,
        _not_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// BinaryOperator: AndOp;
    ///
    fn binary_operator_16(
        &mut self,
        _and_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// BinaryOperator: OrOp;
    ///
    fn binary_operator_17(
        &mut self,
        _or_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// BinaryOperator: XorOp;
    ///
    fn binary_operator_18(
        &mut self,
        _xor_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// BinaryOperator: NorOp;
    ///
    fn binary_operator_19(
        &mut self,
        _nor_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// BinaryOperator: NandOp;
    ///
    fn binary_operator_20(
        &mut self,
        _nand_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// BinaryOperator: XnorOp;
    ///
    fn binary_operator_21(
        &mut self,
        _xnor_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// AndOp: "(?i)AND";
    ///
    fn and_op_22(
        &mut self,
        _and_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// OrOp: "(?i)OR";
    ///
    fn or_op_23(
        &mut self,
        _or_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// XorOp: "(?i)XOR";
    ///
    fn xor_op_24(
        &mut self,
        _xor_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// NorOp: "(?i)NOR";
    ///
    fn nor_op_25(
        &mut self,
        _nor_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// NandOp: "(?i)NAND";
    ///
    fn nand_op_26(
        &mut self,
        _nand_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// XnorOp: "(?i)XNOR";
    ///
    fn xnor_op_27(
        &mut self,
        _xnor_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// True: "(?i)TRUE";
    ///
    fn true_28(
        &mut self,
        _true_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// False: "(?i)FALSE";
    ///
    fn false_29(
        &mut self,
        _false_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// Not: "(?i)NOT";
    ///
    fn not_30(
        &mut self,
        _not_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// Parenthesized: LeftParenthesis Expression RightParenthesis;
    ///
    fn parenthesized_31(
        &mut self,
        _left_parenthesis_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _right_parenthesis_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// Semicolon: ";";
    ///
    fn semicolon_32(
        &mut self,
        _semicolon_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// LeftParenthesis: "\(";
    ///
    fn left_parenthesis_33(
        &mut self,
        _left_parenthesis_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// RightParenthesis: "\)";
    ///
    fn right_parenthesis_34(
        &mut self,
        _right_parenthesis_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// Factor: Boolean;
    ///
    fn factor_35(
        &mut self,
        _boolean_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// Factor: Parenthesized;
    ///
    fn factor_36(
        &mut self,
        _parenthesized_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }
}

impl UserActionsTrait for BooleanGrammar {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// Is is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &std::path::Path) {
        BooleanGrammarTrait::init(self, file_name);
    }

    ///
    /// This function is implemented automatically for the user's item BooleanGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry],
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        match prod_num {
            0 => self.expressions_0(&children[0], &children[1], &children[2], parse_tree),

            1 => self.expressions_suffix_1(&children[0], parse_tree),

            2 => self.expressions_suffix_2(parse_tree),

            3 => self.expressions_opt_3(&children[0], parse_tree),

            4 => self.expressions_list_4(&children[0], &children[1], &children[2], parse_tree),

            5 => self.expressions_list_5(parse_tree),

            6 => self.expression_6(&children[0], &children[1], parse_tree),

            7 => self.tail_expression_7(&children[0], parse_tree),

            8 => self.tail_expression_list_8(&children[0], &children[1], &children[2], parse_tree),

            9 => self.tail_expression_list_9(parse_tree),

            10 => self.term_10(&children[0], &children[1], parse_tree),

            11 => self.term_11(&children[0], parse_tree),

            12 => self.term_opt_12(&children[0], parse_tree),

            13 => self.boolean_13(&children[0], parse_tree),

            14 => self.boolean_14(&children[0], parse_tree),

            15 => self.unary_operator_15(&children[0], parse_tree),

            16 => self.binary_operator_16(&children[0], parse_tree),

            17 => self.binary_operator_17(&children[0], parse_tree),

            18 => self.binary_operator_18(&children[0], parse_tree),

            19 => self.binary_operator_19(&children[0], parse_tree),

            20 => self.binary_operator_20(&children[0], parse_tree),

            21 => self.binary_operator_21(&children[0], parse_tree),

            22 => self.and_op_22(&children[0], parse_tree),

            23 => self.or_op_23(&children[0], parse_tree),

            24 => self.xor_op_24(&children[0], parse_tree),

            25 => self.nor_op_25(&children[0], parse_tree),

            26 => self.nand_op_26(&children[0], parse_tree),

            27 => self.xnor_op_27(&children[0], parse_tree),

            28 => self.true_28(&children[0], parse_tree),

            29 => self.false_29(&children[0], parse_tree),

            30 => self.not_30(&children[0], parse_tree),

            31 => self.parenthesized_31(&children[0], &children[1], &children[2], parse_tree),

            32 => self.semicolon_32(&children[0], parse_tree),

            33 => self.left_parenthesis_33(&children[0], parse_tree),

            34 => self.right_parenthesis_34(&children[0], parse_tree),

            35 => self.factor_35(&children[0], parse_tree),

            36 => self.factor_36(&children[0], parse_tree),

            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
