// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use crate::list_grammar::ListGrammar;
use id_tree::Tree;
use miette::{miette, Result};
use parol_runtime::lexer::OwnedToken;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

//
// Output Types of productions deduced from the structure of the transformed grammar
//

/// Type derived for production 0
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct List0 {
    opt: Option<Box<ListOpt>>,
}

/// Type derived for production 1
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct List1 {
    opt: Option<Box<ListOpt>>,
}

/// Type derived for production 2
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ListOpt2 {
    num_0: Box<Num>,
    list_rest_1: Box<ListRest>,
    list_opt_suffix_2: Box<ListOptSuffix>,
}

/// Type derived for production 3
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ListOptSuffix3 {
    opt: Option<Box<ListOptOpt>>,
}

/// Type derived for production 4
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ListOptSuffix4 {
    opt: Option<Box<ListOptOpt>>,
}

/// Type derived for production 5
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ListOptOpt5 {
    list_opt_opt_0: OwnedToken, /* , */
}

/// Type derived for production 6
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ListRest6 {
    opt: Option<Box<ListRestOpt>>,
}

/// Type derived for production 7
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ListRest7 {
    opt: Option<Box<ListRestOpt>>,
}

/// Type derived for production 8
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ListRestOpt8 {
    list_opt_opt_0: OwnedToken, /* , */
    num_1: Box<Num>,
    list_rest_2: Box<ListRest>,
}

/// Type derived for production 9
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Num9 {
    num_0: OwnedToken, /* 0|[1-9][0-9]* */
}

//
// Types of non-terminals deduced from the structure of the transformed grammar
//

/// Type derived for non-terminal List
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct List {
    opt: Option<Box<ListOpt>>,
}

/// Type derived for non-terminal ListOpt
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ListOpt {
    num_0: Box<Num>,
    list_rest_1: Box<ListRest>,
    list_opt_suffix_2: Box<ListOptSuffix>,
}

/// Type derived for non-terminal ListOptOpt
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ListOptOpt {
    list_opt_opt_0: OwnedToken, /* , */
}

/// Type derived for non-terminal ListOptSuffix
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ListOptSuffix {
    opt: Option<Box<ListOptOpt>>,
}

/// Type derived for non-terminal ListRest
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ListRest {
    opt: Option<Box<ListRestOpt>>,
}

/// Type derived for non-terminal ListRestOpt
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ListRestOpt {
    list_opt_opt_0: OwnedToken, /* , */
    num_1: Box<Num>,
    list_rest_2: Box<ListRest>,
}

/// Type derived for non-terminal Num
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Num {
    num_0: OwnedToken, /* 0|[1-9][0-9]* */
}

//
// AST type of the transformed grammar
//

/// Derived from production output types
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum ASTType {
    List(List),
    ListOpt(ListOpt),
    ListOptOpt(ListOptOpt),
    ListOptSuffix(ListOptSuffix),
    ListRest(ListRest),
    ListRestOpt(ListRestOpt),
    Num(Num),
}

///
/// The `ListGrammarTrait` trait is automatically generated for the
/// given grammar.
/// All functions have default implementations.
///
pub trait ListGrammarTrait {
    ///
    /// Implement this method if you need the provided information
    ///
    fn init(&mut self, _file_name: &std::path::Path) {}

    /// Semantic action for production 0:
    ///
    /// List: ListOpt;
    ///
    fn list_0(
        &mut self,
        _list_opt_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// List: /* Option<ListOpt>::None */;
    ///
    fn list_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// ListOpt: Num ListRest ListOptSuffix;
    ///
    fn list_opt_2(
        &mut self,
        _num_0: &ParseTreeStackEntry,
        _list_rest_1: &ParseTreeStackEntry,
        _list_opt_suffix_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// ListOptSuffix: ListOptOpt;
    ///
    fn list_opt_suffix_3(
        &mut self,
        _list_opt_opt_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// ListOptSuffix: /* Option<ListOptOpt>::None */;
    ///
    fn list_opt_suffix_4(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// ListOptOpt: ",";
    ///
    fn list_opt_opt_5(
        &mut self,
        _list_opt_opt_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// ListRest: ListRestOpt;
    ///
    fn list_rest_6(
        &mut self,
        _list_rest_opt_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// ListRest: /* Option<ListRestOpt>::None */;
    ///
    fn list_rest_7(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// ListRestOpt: "," Num ListRest;
    ///
    fn list_rest_opt_8(
        &mut self,
        _list_opt_opt_0: &ParseTreeStackEntry,
        _num_1: &ParseTreeStackEntry,
        _list_rest_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// Num: "0|[1-9][0-9]*";
    ///
    fn num_9(
        &mut self,
        _num_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }
}

impl UserActionsTrait for ListGrammar {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// Is is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &std::path::Path) {
        ListGrammarTrait::init(self, file_name);
    }

    ///
    /// This function is implemented automatically for the user's item ListGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry],
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        match prod_num {
            0 => self.list_0(&children[0], parse_tree),

            1 => self.list_1(parse_tree),

            2 => self.list_opt_2(&children[0], &children[1], &children[2], parse_tree),

            3 => self.list_opt_suffix_3(&children[0], parse_tree),

            4 => self.list_opt_suffix_4(parse_tree),

            5 => self.list_opt_opt_5(&children[0], parse_tree),

            6 => self.list_rest_6(&children[0], parse_tree),

            7 => self.list_rest_7(parse_tree),

            8 => self.list_rest_opt_8(&children[0], &children[1], &children[2], parse_tree),

            9 => self.num_9(&children[0], parse_tree),

            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
