// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use crate::scanner_states_grammar::ScannerStatesGrammar;
use id_tree::Tree;
use miette::{miette, Result};
use parol_runtime::lexer::OwnedToken;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

//
// Output Types of productions deduced from the structure of the transformed grammar
//

/// Type derived for production 0
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Start0 {
    start_list_0: Box<StartList>,
}

/// Type derived for production 3
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Content3 {
    identifier_0: Box<Identifier>,
}

/// Type derived for production 4
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Content4 {
    string_delimiter_0: Box<StringDelimiter>,
    content_list_2: Box<ContentList>,
    string_delimiter_3: Box<StringDelimiter>,
}

/// Type derived for production 7
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StringElement7 {
    escaped_0: Box<Escaped>,
}

/// Type derived for production 8
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StringElement8 {
    escaped_line_end_0: Box<EscapedLineEnd>,
}

/// Type derived for production 9
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StringElement9 {
    none_quote_0: Box<NoneQuote>,
}

/// Type derived for production 10
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Identifier10 {
    identifier_0: OwnedToken, /* [a-zA-Z]\w* */
}

/// Type derived for production 11
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Escaped11 {
    escaped_0: OwnedToken, /* \u{5c}[\u{22}\u{5c}bfnt] */
}

/// Type derived for production 12
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct EscapedLineEnd12 {
    escaped_line_end_0: OwnedToken, /* \u{5c}[\s^\n\r]*\r?\n */
}

/// Type derived for production 13
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct NoneQuote13 {
    none_quote_0: OwnedToken, /* [^\u{22}\u{5c}]+ */
}

/// Type derived for production 14
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StringDelimiter14 {
    string_delimiter_0: OwnedToken, /* \u{22} */
}

//
// Types of non-terminals deduced from the structure of the transformed grammar
//

/// Type derived for non-terminal Content
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum Content {
    Content0(Box<Content3>),
    Content1(Box<Content4>),
}

/// Type derived for non-terminal ContentList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ContentList {
    vec: Vec<StringElement>,
}

/// Type derived for non-terminal Escaped
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Escaped {
    escaped_0: OwnedToken, /* \u{5c}[\u{22}\u{5c}bfnt] */
}

/// Type derived for non-terminal EscapedLineEnd
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct EscapedLineEnd {
    escaped_line_end_0: OwnedToken, /* \u{5c}[\s^\n\r]*\r?\n */
}

/// Type derived for non-terminal Identifier
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Identifier {
    identifier_0: OwnedToken, /* [a-zA-Z]\w* */
}

/// Type derived for non-terminal NoneQuote
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct NoneQuote {
    none_quote_0: OwnedToken, /* [^\u{22}\u{5c}]+ */
}

/// Type derived for non-terminal Start
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Start {
    start_list_0: Box<StartList>,
}

/// Type derived for non-terminal StartList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StartList {
    vec: Vec<Content>,
}

/// Type derived for non-terminal StringDelimiter
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StringDelimiter {
    string_delimiter_0: OwnedToken, /* \u{22} */
}

/// Type derived for non-terminal StringElement
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum StringElement {
    StringElement0(Box<StringElement7>),
    StringElement1(Box<StringElement8>),
    StringElement2(Box<StringElement9>),
}

//
// AST type of the transformed grammar
//

/// Derived from production output types
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum ASTType {
    Content(Content),
    ContentList(ContentList),
    Escaped(Escaped),
    EscapedLineEnd(EscapedLineEnd),
    Identifier(Identifier),
    NoneQuote(NoneQuote),
    Start(Start),
    StartList(StartList),
    StringDelimiter(StringDelimiter),
    StringElement(StringElement),
}

///
/// The `ScannerStatesGrammarTrait` trait is automatically generated for the
/// given grammar.
/// All functions have default implementations.
///
pub trait ScannerStatesGrammarTrait {
    ///
    /// Implement this method if you need the provided information
    ///
    fn init(&mut self, _file_name: &std::path::Path) {}

    /// Semantic action for production 0:
    ///
    /// Start: StartList;
    ///
    fn start_0(
        &mut self,
        _start_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// StartList: Content StartList;
    ///
    fn start_list_1(
        &mut self,
        _content_0: &ParseTreeStackEntry,
        _start_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// StartList: /* Vec<StartList>::New */;
    ///
    fn start_list_2(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// Content: Identifier;
    ///
    fn content_3(
        &mut self,
        _identifier_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// Content: StringDelimiter %push(String) ContentList StringDelimiter %pop();
    ///
    fn content_4(
        &mut self,
        _string_delimiter_0: &ParseTreeStackEntry,
        _content_list_2: &ParseTreeStackEntry,
        _string_delimiter_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// ContentList: StringElement ContentList;
    ///
    fn content_list_5(
        &mut self,
        _string_element_0: &ParseTreeStackEntry,
        _content_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// ContentList: /* Vec<ContentList>::New */;
    ///
    fn content_list_6(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// StringElement: Escaped;
    ///
    fn string_element_7(
        &mut self,
        _escaped_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// StringElement: EscapedLineEnd;
    ///
    fn string_element_8(
        &mut self,
        _escaped_line_end_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// StringElement: NoneQuote;
    ///
    fn string_element_9(
        &mut self,
        _none_quote_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// Identifier: "[a-zA-Z_]\w*";
    ///
    fn identifier_10(
        &mut self,
        _identifier_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// Escaped: <String>"\u{5c}[\u{22}\u{5c}bfnt]";
    ///
    fn escaped_11(
        &mut self,
        _escaped_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// EscapedLineEnd: <String>"\u{5c}[\s^\n\r]*\r?\n";
    ///
    fn escaped_line_end_12(
        &mut self,
        _escaped_line_end_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// NoneQuote: <String>"[^\u{22}\u{5c}]+";
    ///
    fn none_quote_13(
        &mut self,
        _none_quote_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// StringDelimiter: <INITIAL, String>"\u{22}";
    ///
    fn string_delimiter_14(
        &mut self,
        _string_delimiter_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }
}

impl UserActionsTrait for ScannerStatesGrammar {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// Is is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &std::path::Path) {
        ScannerStatesGrammarTrait::init(self, file_name);
    }

    ///
    /// This function is implemented automatically for the user's item ScannerStatesGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry],
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        match prod_num {
            0 => self.start_0(&children[0], parse_tree),

            1 => self.start_list_1(&children[0], &children[1], parse_tree),

            2 => self.start_list_2(parse_tree),

            3 => self.content_3(&children[0], parse_tree),

            4 => self.content_4(&children[0], &children[1], &children[2], parse_tree),

            5 => self.content_list_5(&children[0], &children[1], parse_tree),

            6 => self.content_list_6(parse_tree),

            7 => self.string_element_7(&children[0], parse_tree),

            8 => self.string_element_8(&children[0], parse_tree),

            9 => self.string_element_9(&children[0], parse_tree),

            10 => self.identifier_10(&children[0], parse_tree),

            11 => self.escaped_11(&children[0], parse_tree),

            12 => self.escaped_line_end_12(&children[0], parse_tree),

            13 => self.none_quote_13(&children[0], parse_tree),

            14 => self.string_delimiter_14(&children[0], parse_tree),

            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
