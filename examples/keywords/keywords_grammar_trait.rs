// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use crate::keywords_grammar::KeywordsGrammar;
use id_tree::Tree;
use miette::{miette, Result};
use parol_runtime::lexer::OwnedToken;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

//
// Output Types of productions deduced from the structure of the transformed grammar
//

/// Type derived for production 0
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Grammar0 {
    grammar_list_0: Box<GrammarList>,
}

/// Type derived for production 3
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Items3 {
    declaration_0: Box<Declaration>,
}

/// Type derived for production 4
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Items4 {
    block_0: Box<Block>,
}

/// Type derived for production 5
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Declaration5 {
    var_0: Box<Var>,
    identifier_1: Box<Identifier>,
    semicolon_2: OwnedToken, /* ; */
}

/// Type derived for production 6
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Block6 {
    begin_0: Box<Begin>,
    block_list_1: Box<BlockList>,
    end_2: Box<End>,
}

/// Type derived for production 9
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Begin9 {
    begin_0: OwnedToken, /* (?i)\bBegin\b */
}

/// Type derived for production 10
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct End10 {
    end_0: OwnedToken, /* (?i)\bEnd\b */
}

/// Type derived for production 11
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Var11 {
    var_0: OwnedToken, /* (?i)\bVar\b */
}

/// Type derived for production 12
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Identifier12 {
    identifier_0: OwnedToken, /* [a-zA-Z][a-zA-Z0-9]* */
}

//
// Types of non-terminals deduced from the structure of the transformed grammar
//

/// Type derived for non-terminal Begin
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Begin {
    begin_0: OwnedToken, /* (?i)\bBegin\b */
}

/// Type derived for non-terminal Block
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Block {
    begin_0: Box<Begin>,
    block_list_1: Box<BlockList>,
    end_2: Box<End>,
}

/// Type derived for non-terminal BlockList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct BlockList {
    vec: Vec<Items>,
}

/// Type derived for non-terminal Declaration
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Declaration {
    var_0: Box<Var>,
    identifier_1: Box<Identifier>,
    semicolon_2: OwnedToken, /* ; */
}

/// Type derived for non-terminal End
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct End {
    end_0: OwnedToken, /* (?i)\bEnd\b */
}

/// Type derived for non-terminal Grammar
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Grammar {
    grammar_list_0: Box<GrammarList>,
}

/// Type derived for non-terminal GrammarList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct GrammarList {
    vec: Vec<Items>,
}

/// Type derived for non-terminal Identifier
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Identifier {
    identifier_0: OwnedToken, /* [a-zA-Z][a-zA-Z0-9]* */
}

/// Type derived for non-terminal Items
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum Items {
    Items0(Box<Items3>),
    Items1(Box<Items4>),
}

/// Type derived for non-terminal Var
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Var {
    var_0: OwnedToken, /* (?i)\bVar\b */
}

//
// AST type of the transformed grammar
//

/// Derived from production output types
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum ASTType {
    Begin(Begin),
    Block(Block),
    BlockList(BlockList),
    Declaration(Declaration),
    End(End),
    Grammar(Grammar),
    GrammarList(GrammarList),
    Identifier(Identifier),
    Items(Items),
    Var(Var),
}

///
/// The `KeywordsGrammarTrait` trait is automatically generated for the
/// given grammar.
/// All functions have default implementations.
///
pub trait KeywordsGrammarTrait {
    ///
    /// Implement this method if you need the provided information
    ///
    fn init(&mut self, _file_name: &std::path::Path) {}

    /// Semantic action for production 0:
    ///
    /// Grammar: GrammarList;
    ///
    fn grammar_0(
        &mut self,
        _grammar_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// GrammarList: Items GrammarList;
    ///
    fn grammar_list_1(
        &mut self,
        _items_0: &ParseTreeStackEntry,
        _grammar_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// GrammarList: /* Vec<GrammarList>::New */;
    ///
    fn grammar_list_2(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// Items: Declaration;
    ///
    fn items_3(
        &mut self,
        _declaration_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// Items: Block;
    ///
    fn items_4(
        &mut self,
        _block_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// Declaration: Var Identifier ";";
    ///
    fn declaration_5(
        &mut self,
        _var_0: &ParseTreeStackEntry,
        _identifier_1: &ParseTreeStackEntry,
        _semicolon_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// Block: Begin BlockList End;
    ///
    fn block_6(
        &mut self,
        _begin_0: &ParseTreeStackEntry,
        _block_list_1: &ParseTreeStackEntry,
        _end_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// BlockList: Items BlockList;
    ///
    fn block_list_7(
        &mut self,
        _items_0: &ParseTreeStackEntry,
        _block_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// BlockList: /* Vec<BlockList>::New */;
    ///
    fn block_list_8(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// Begin: "(?i)\bBegin\b";
    ///
    fn begin_9(
        &mut self,
        _begin_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// End: "(?i)\bEnd\b";
    ///
    fn end_10(
        &mut self,
        _end_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// Var: "(?i)\bVar\b";
    ///
    fn var_11(
        &mut self,
        _var_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// Identifier: "[a-zA-Z_][a-zA-Z0-9_]*";
    ///
    fn identifier_12(
        &mut self,
        _identifier_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }
}

impl UserActionsTrait for KeywordsGrammar {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// Is is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &std::path::Path) {
        KeywordsGrammarTrait::init(self, file_name);
    }

    ///
    /// This function is implemented automatically for the user's item KeywordsGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry],
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        match prod_num {
            0 => self.grammar_0(&children[0], parse_tree),

            1 => self.grammar_list_1(&children[0], &children[1], parse_tree),

            2 => self.grammar_list_2(parse_tree),

            3 => self.items_3(&children[0], parse_tree),

            4 => self.items_4(&children[0], parse_tree),

            5 => self.declaration_5(&children[0], &children[1], &children[2], parse_tree),

            6 => self.block_6(&children[0], &children[1], &children[2], parse_tree),

            7 => self.block_list_7(&children[0], &children[1], parse_tree),

            8 => self.block_list_8(parse_tree),

            9 => self.begin_9(&children[0], parse_tree),

            10 => self.end_10(&children[0], parse_tree),

            11 => self.var_11(&children[0], parse_tree),

            12 => self.identifier_12(&children[0], parse_tree),

            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
