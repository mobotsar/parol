// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use crate::oberon_0_grammar::Oberon0Grammar;
use id_tree::Tree;
use miette::{miette, Result};
use parol_runtime::lexer::OwnedToken;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

//
// Output Types of productions deduced from the structure of the transformed grammar
//

/// Type derived for production 0
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Selector0 {
    selector_list_0: Box<SelectorList>,
}

/// Type derived for production 2
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct SelectorListGroup2 {
    dot_0: OwnedToken, /* \. */
    ident_1: Box<Ident>,
}

/// Type derived for production 3
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct SelectorListGroup3 {
    l_bracket_0: OwnedToken, /* \[ */
    expression_1: Box<Expression>,
    r_bracket_2: OwnedToken, /* ] */
}

/// Type derived for production 5
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Factor5 {
    ident_0: Box<Ident>,
    selector_1: Box<Selector>,
}

/// Type derived for production 6
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Factor6 {
    integer_0: Box<Integer>,
}

/// Type derived for production 7
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Factor7 {
    l_paren_0: OwnedToken, /* \( */
    expression_1: Box<Expression>,
    r_paren_2: OwnedToken, /* \) */
}

/// Type derived for production 8
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Factor8 {
    tilde_0: OwnedToken, /* ~ */
    factor_1: Box<Factor>,
}

/// Type derived for production 9
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Factor9 {
    unary_op_0: Box<UnaryOp>,
    factor_1: Box<Factor>,
}

/// Type derived for production 10
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Term10 {
    factor_0: Box<Factor>,
    mul_expression_1: Box<MulExpression>,
}

/// Type derived for production 11
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct MulExpression11 {
    mul_expression_list_0: Box<MulExpressionList>,
}

/// Type derived for production 14
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct SimpleExpression14 {
    term_0: Box<Term>,
    add_expression_1: Box<AddExpression>,
}

/// Type derived for production 15
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AddExpression15 {
    add_expression_list_0: Box<AddExpressionList>,
}

/// Type derived for production 18
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AssignOp18 {
    colon_equ_0: OwnedToken, /* := */
}

/// Type derived for production 19
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RelationOp19 {
    assign_op_0: Box<AssignOp>,
}

/// Type derived for production 20
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RelationOp20 {
    relational_ops_0: Box<RelationalOps>,
}

/// Type derived for production 21
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RelationalOps21 {
    relational_ops_0: OwnedToken, /* >=|<=|\#|<|> */
}

/// Type derived for production 22
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AssignOp22 {
    equ_0: OwnedToken, /* = */
}

/// Type derived for production 23
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Expression23 {
    simple_expression_0: Box<SimpleExpression>,
    expression_suffix_1: Box<ExpressionSuffix>,
}

/// Type derived for production 24
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ExpressionSuffix24 {
    opt: Option<Box<ExpressionOpt>>,
}

/// Type derived for production 25
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ExpressionSuffix25 {
    opt: Option<Box<ExpressionOpt>>,
}

/// Type derived for production 26
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ExpressionOpt26 {
    relation_op_0: Box<RelationOp>,
    simple_expression_1: Box<SimpleExpression>,
}

/// Type derived for production 27
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Assignment27 {
    ident_0: Box<Ident>,
    selector_1: Box<Selector>,
    assign_op_2: Box<AssignOp>,
    expression_3: Box<Expression>,
}

/// Type derived for production 28
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ActualParameters28 {
    l_paren_0: OwnedToken, /* \( */
    actual_parameters_suffix_1: Box<ActualParametersSuffix>,
}

/// Type derived for production 29
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ActualParametersSuffix29 {
    actual_parameters_opt_0: Box<ActualParametersOpt>,
    r_paren_1: OwnedToken, /* \) */
}

/// Type derived for production 30
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ActualParametersSuffix30 {
    r_paren_0: (),
}

/// Type derived for production 31
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ActualParametersOpt31 {
    expression_0: Box<Expression>,
    actual_parameters_opt_list_1: Box<ActualParametersOptList>,
}

/// Type derived for production 34
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureCall34 {
    ident_0: Box<Ident>,
    procedure_call_suffix_1: Box<ProcedureCallSuffix>,
}

/// Type derived for production 35
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureCallSuffix35 {
    opt: Option<Box<ProcedureCallOpt>>,
}

/// Type derived for production 36
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureCallSuffix36 {
    opt: Option<Box<ProcedureCallOpt>>,
}

/// Type derived for production 37
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureCallOpt37 {
    actual_parameters_0: Box<ActualParameters>,
}

/// Type derived for production 38
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct IfStatement38 {
    if_prefix_0: Box<IfPrefix>,
    if_statement_suffix_1: Box<IfStatementSuffix>,
}

/// Type derived for production 39
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct IfStatementSuffix39 {
    if_statement_opt_0: Box<IfStatementOpt>,
    e_n_d_1: OwnedToken, /* END */
}

/// Type derived for production 40
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct IfStatementSuffix40 {
    e_n_d_0: (),
}

/// Type derived for production 41
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct IfStatementOpt41 {
    e_l_s_e_0: OwnedToken, /* ELSE */
    statement_sequence_1: Box<StatementSequence>,
}

/// Type derived for production 42
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct IfPrefix42 {
    i_f_0: OwnedToken, /* IF */
    expression_1: Box<Expression>,
    t_h_e_n_2: OwnedToken, /* THEN */
    statement_sequence_3: Box<StatementSequence>,
    if_prefix_list_4: Box<IfPrefixList>,
}

/// Type derived for production 45
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct WhileStatement45 {
    w_h_i_l_e_0: OwnedToken, /* WHILE */
    expression_1: Box<Expression>,
    d_o_2: OwnedToken, /* DO */
    statement_sequence_3: Box<StatementSequence>,
    e_n_d_4: OwnedToken, /* END */
}

/// Type derived for production 46
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RepeatStatement46 {
    r_e_p_e_a_t_0: OwnedToken, /* REPEAT */
    statement_sequence_1: Box<StatementSequence>,
    u_n_t_i_l_2: OwnedToken, /* UNTIL */
    expression_3: Box<Expression>,
}

/// Type derived for production 47
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Statement47 {
    assignment_0: Box<Assignment>,
}

/// Type derived for production 48
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Statement48 {
    procedure_call_0: Box<ProcedureCall>,
}

/// Type derived for production 49
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Statement49 {
    if_statement_0: Box<IfStatement>,
}

/// Type derived for production 50
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Statement50 {
    while_statement_0: Box<WhileStatement>,
}

/// Type derived for production 51
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Statement51 {
    repeat_statement_0: Box<RepeatStatement>,
}

/// Type derived for production 52
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StatementSequence52 {
    statement_sequence_opt_0: Box<StatementSequenceOpt>,
    statement_sequence_list_1: Box<StatementSequenceList>,
}

/// Type derived for production 53
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StatementSequence53 {
    statement_sequence_list_0: (),
}

/// Type derived for production 54
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StatementSequenceOpt54 {
    statement_0: Box<Statement>,
}

/// Type derived for production 56
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StatementSequenceListSuffix56 {
    statement_sequence_opt_0: Box<StatementSequenceOpt>,
    statement_sequence_list_1: Box<StatementSequenceList>,
}

/// Type derived for production 57
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StatementSequenceListSuffix57 {
    statement_sequence_list_0: (),
}

/// Type derived for production 59
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct IdentList59 {
    ident_0: Box<Ident>,
    ident_list_list_1: Box<IdentListList>,
}

/// Type derived for production 62
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ArrayType62 {
    a_r_r_a_y_0: OwnedToken, /* ARRAY */
    expression_1: Box<Expression>,
    o_f_2: OwnedToken, /* OF */
    type_3: Box<Type>,
}

/// Type derived for production 63
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct FieldList63 {
    ident_list_0: Box<IdentList>,
    colon_1: OwnedToken, /* : */
    type_2: Box<Type>,
}

/// Type derived for production 64
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RecordType64 {
    r_e_c_o_r_d_0: OwnedToken, /* RECORD */
    record_type_suffix_1: Box<RecordTypeSuffix>,
}

/// Type derived for production 65
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RecordTypeSuffix65 {
    record_type_opt_0: Box<RecordTypeOpt>,
    record_type_list_1: Box<RecordTypeList>,
    e_n_d_2: OwnedToken, /* END */
}

/// Type derived for production 66
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RecordTypeSuffix66 {
    record_type_list_1: Box<RecordTypeList>,
    e_n_d_2: OwnedToken, /* END */
}

/// Type derived for production 67
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RecordTypeOpt67 {
    field_list_0: Box<FieldList>,
}

/// Type derived for production 69
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RecordTypeListSuffix69 {
    record_type_opt_0: Box<RecordTypeOpt>,
    record_type_list_1: Box<RecordTypeList>,
}

/// Type derived for production 70
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RecordTypeListSuffix70 {
    record_type_list_0: (),
}

/// Type derived for production 72
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Type72 {
    ident_0: Box<Ident>,
}

/// Type derived for production 73
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Type73 {
    array_type_0: Box<ArrayType>,
}

/// Type derived for production 74
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Type74 {
    record_type_0: Box<RecordType>,
}

/// Type derived for production 75
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct FPSection75 {
    f_p_section_opt_0: Box<FPSectionOpt>,
    ident_list_1: Box<IdentList>,
    colon_2: OwnedToken, /* : */
    type_3: Box<Type>,
}

/// Type derived for production 76
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct FPSection76 {
    ident_list_1: Box<IdentList>,
    colon_2: OwnedToken, /* : */
    type_3: Box<Type>,
}

/// Type derived for production 77
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct FPSectionOpt77 {
    f_p_section_opt_0: OwnedToken, /* VAR */
}

/// Type derived for production 78
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct FormalParameters78 {
    l_paren_0: OwnedToken, /* \( */
    formal_parameters_suffix_1: Box<FormalParametersSuffix>,
}

/// Type derived for production 79
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct FormalParametersSuffix79 {
    formal_parameters_opt_0: Box<FormalParametersOpt>,
    r_paren_1: OwnedToken, /* \) */
}

/// Type derived for production 80
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct FormalParametersSuffix80 {
    r_paren_0: (),
}

/// Type derived for production 81
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct FormalParametersOpt81 {
    f_p_section_0: Box<FPSection>,
    formal_parameters_opt_list_1: Box<FormalParametersOptList>,
}

/// Type derived for production 84
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureHeading84 {
    p_r_o_c_e_d_u_r_e_0: OwnedToken, /* PROCEDURE */
    ident_1: Box<Ident>,
    procedure_heading_suffix_2: Box<ProcedureHeadingSuffix>,
}

/// Type derived for production 85
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureHeadingSuffix85 {
    opt: Option<Box<ProcedureHeadingOpt>>,
}

/// Type derived for production 86
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureHeadingSuffix86 {
    opt: Option<Box<ProcedureHeadingOpt>>,
}

/// Type derived for production 87
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureHeadingOpt87 {
    formal_parameters_0: Box<FormalParameters>,
}

/// Type derived for production 88
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureBody88 {
    declarations_0: Box<Declarations>,
    procedure_body_suffix1_1: Box<ProcedureBodySuffix1>,
}

/// Type derived for production 89
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureBodySuffix1_89 {
    b_e_g_i_n_0: OwnedToken, /* BEGIN */
    statement_sequence_1: Box<StatementSequence>,
    procedure_body_suffix_2: Box<ProcedureBodySuffix>,
}

/// Type derived for production 90
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureBodySuffix1_90 {
    r_e_t_u_r_n_0: OwnedToken, /* RETURN */
    expression_1: Box<Expression>,
    e_n_d_2: OwnedToken, /* END */
    ident_3: Box<Ident>,
}

/// Type derived for production 91
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureBodySuffix1_91 {
    e_n_d_0: OwnedToken, /* END */
    ident_1: Box<Ident>,
}

/// Type derived for production 92
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureBodySuffix92 {
    r_e_t_u_r_n_0: OwnedToken, /* RETURN */
    expression_1: Box<Expression>,
    e_n_d_2: OwnedToken, /* END */
    ident_3: Box<Ident>,
}

/// Type derived for production 93
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureBodySuffix93 {
    e_n_d_0: OwnedToken, /* END */
    ident_1: Box<Ident>,
}

/// Type derived for production 94
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureDeclaration94 {
    procedure_heading_0: Box<ProcedureHeading>,
    semicolon_1: OwnedToken, /* ; */
    procedure_body_2: Box<ProcedureBody>,
}

/// Type derived for production 95
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Declarations95 {
    type_0: OwnedToken, /* Type */
    type_decls_1: Box<TypeDecls>,
    declarations_suffix2_2: Box<DeclarationsSuffix2>,
}

/// Type derived for production 96
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Declarations96 {
    c_o_n_s_t_0: OwnedToken, /* CONST */
    const_decls_1: Box<ConstDecls>,
    declarations_suffix1_2: Box<DeclarationsSuffix1>,
}

/// Type derived for production 97
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct DeclarationsSuffix2_97 {
    declarations_opt_0: Box<DeclarationsOpt>,
    procedure_declaration_list_1: Box<ProcedureDeclarationList>,
}

/// Type derived for production 98
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct DeclarationsSuffix2_98 {
    procedure_declaration_list_0: (),
}

/// Type derived for production 99
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Declarations99 {
    f_p_section_opt_0: OwnedToken, /* VAR */
    var_decls_1: Box<VarDecls>,
    procedure_declaration_list_2: Box<ProcedureDeclarationList>,
}

/// Type derived for production 100
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Declarations100 {
    procedure_declaration_list_0: Box<ProcedureDeclarationList>,
}

/// Type derived for production 101
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct DeclarationsSuffix1_101 {
    type_0: OwnedToken, /* Type */
    type_decls_1: Box<TypeDecls>,
    declarations_suffix_2: Box<DeclarationsSuffix>,
}

/// Type derived for production 102
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct DeclarationsSuffix1_102 {
    declarations_opt_0: Box<DeclarationsOpt>,
    procedure_declaration_list_1: Box<ProcedureDeclarationList>,
}

/// Type derived for production 103
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct DeclarationsSuffix1_103 {
    procedure_declaration_list_0: (),
}

/// Type derived for production 104
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct DeclarationsSuffix104 {
    declarations_opt_0: Box<DeclarationsOpt>,
    procedure_declaration_list_1: Box<ProcedureDeclarationList>,
}

/// Type derived for production 105
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct DeclarationsSuffix105 {
    procedure_declaration_list_0: (),
}

/// Type derived for production 106
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct DeclarationsOpt106 {
    f_p_section_opt_0: OwnedToken, /* VAR */
    var_decls_1: Box<VarDecls>,
}

/// Type derived for production 107
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureDeclarationList107 {
    procedure_declaration_list_list_0: Box<ProcedureDeclarationListList>,
}

/// Type derived for production 110
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ConstDecls110 {
    const_decls_list_0: Box<ConstDeclsList>,
}

/// Type derived for production 113
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct TypeDecls113 {
    type_decls_list_0: Box<TypeDeclsList>,
}

/// Type derived for production 116
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct VarDecls116 {
    var_decls_list_0: Box<VarDeclsList>,
}

/// Type derived for production 119
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Module119 {
    m_o_d_u_l_e_0: OwnedToken, /* MODULE */
    ident_1: Box<Ident>,
    semicolon_2: OwnedToken, /* ; */
    declarations_3: Box<Declarations>,
    module_suffix_4: Box<ModuleSuffix>,
}

/// Type derived for production 120
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ModuleSuffix120 {
    module_opt_0: Box<ModuleOpt>,
    e_n_d_1: OwnedToken, /* END */
    ident_2: Box<Ident>,
    dot_3: OwnedToken, /* \. */
}

/// Type derived for production 121
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ModuleSuffix121 {
    e_n_d_1: OwnedToken, /* END */
    ident_2: Box<Ident>,
    dot_3: OwnedToken, /* \. */
}

/// Type derived for production 122
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ModuleOpt122 {
    b_e_g_i_n_0: OwnedToken, /* BEGIN */
    statement_sequence_1: Box<StatementSequence>,
}

/// Type derived for production 123
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct MulOperator123 {
    mul_operator_0: OwnedToken, /* \*|/|DIV|MOD|& */
}

/// Type derived for production 124
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AddOperator124 {
    add_operator_0: OwnedToken, /* \+|-|OR */
}

/// Type derived for production 125
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct UnaryOp125 {
    unary_op_0: OwnedToken, /* \+|- */
}

/// Type derived for production 126
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Ident126 {
    ident_0: OwnedToken, /* [a-zA-Z][a-zA-Z0-9]* */
}

/// Type derived for production 127
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Integer127 {
    integer_0: OwnedToken, /* [0-9]+ */
}

//
// Types of non-terminals deduced from the structure of the transformed grammar
//

/// Type derived for non-terminal ActualParameters
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ActualParameters {
    l_paren_0: OwnedToken, /* \( */
    actual_parameters_suffix_1: Box<ActualParametersSuffix>,
}

/// Type derived for non-terminal ActualParametersOpt
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ActualParametersOpt {
    expression_0: Box<Expression>,
    actual_parameters_opt_list_1: Box<ActualParametersOptList>,
}

/// Type derived for non-terminal ActualParametersOptList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ActualParametersOptList {
    vec: Vec<(OwnedToken /* , */, Expression)>,
}

/// Type derived for non-terminal ActualParametersSuffix
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum ActualParametersSuffix {
    ActualParametersSuffix0(Box<ActualParametersSuffix29>),
    ActualParametersSuffix1(Box<ActualParametersSuffix30>),
}

/// Type derived for non-terminal AddExpression
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AddExpression {
    add_expression_list_0: Box<AddExpressionList>,
}

/// Type derived for non-terminal AddExpressionList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AddExpressionList {
    vec: Vec<(AddOperator, Term)>,
}

/// Type derived for non-terminal AddOperator
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AddOperator {
    add_operator_0: OwnedToken, /* \+|-|OR */
}

/// Type derived for non-terminal ArrayType
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ArrayType {
    a_r_r_a_y_0: OwnedToken, /* ARRAY */
    expression_1: Box<Expression>,
    o_f_2: OwnedToken, /* OF */
    type_3: Box<Type>,
}

/// Type derived for non-terminal AssignOp
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum AssignOp {
    AssignOp0(Box<AssignOp18>),
    AssignOp1(Box<AssignOp22>),
}

/// Type derived for non-terminal Assignment
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Assignment {
    ident_0: Box<Ident>,
    selector_1: Box<Selector>,
    assign_op_2: Box<AssignOp>,
    expression_3: Box<Expression>,
}

/// Type derived for non-terminal ConstDecls
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ConstDecls {
    const_decls_list_0: Box<ConstDeclsList>,
}

/// Type derived for non-terminal ConstDeclsList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ConstDeclsList {
    vec: Vec<(Ident, AssignOp, Expression, OwnedToken /* ; */)>,
}

/// Type derived for non-terminal Expression
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Expression {
    simple_expression_0: Box<SimpleExpression>,
    expression_suffix_1: Box<ExpressionSuffix>,
}

/// Type derived for non-terminal ExpressionOpt
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ExpressionOpt {
    relation_op_0: Box<RelationOp>,
    simple_expression_1: Box<SimpleExpression>,
}

/// Type derived for non-terminal ExpressionSuffix
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ExpressionSuffix {
    opt: Option<Box<ExpressionOpt>>,
}

/// Type derived for non-terminal FPSection
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum FPSection {
    FPSection0(Box<FPSection75>),
    FPSection1(Box<FPSection76>),
}

/// Type derived for non-terminal FPSectionOpt
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct FPSectionOpt {
    f_p_section_opt_0: OwnedToken, /* VAR */
}

/// Type derived for non-terminal Factor
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum Factor {
    Factor0(Box<Factor5>),
    Factor1(Box<Factor6>),
    Factor2(Box<Factor7>),
    Factor3(Box<Factor8>),
    Factor4(Box<Factor9>),
}

/// Type derived for non-terminal FieldList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct FieldList {
    ident_list_0: Box<IdentList>,
    colon_1: OwnedToken, /* : */
    type_2: Box<Type>,
}

/// Type derived for non-terminal FormalParameters
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct FormalParameters {
    l_paren_0: OwnedToken, /* \( */
    formal_parameters_suffix_1: Box<FormalParametersSuffix>,
}

/// Type derived for non-terminal FormalParametersOpt
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct FormalParametersOpt {
    f_p_section_0: Box<FPSection>,
    formal_parameters_opt_list_1: Box<FormalParametersOptList>,
}

/// Type derived for non-terminal FormalParametersOptList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct FormalParametersOptList {
    vec: Vec<(OwnedToken /* ; */, FPSection)>,
}

/// Type derived for non-terminal FormalParametersSuffix
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum FormalParametersSuffix {
    FormalParametersSuffix0(Box<FormalParametersSuffix79>),
    FormalParametersSuffix1(Box<FormalParametersSuffix80>),
}

/// Type derived for non-terminal Ident
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Ident {
    ident_0: OwnedToken, /* [a-zA-Z][a-zA-Z0-9]* */
}

/// Type derived for non-terminal IdentList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct IdentList {
    ident_0: Box<Ident>,
    ident_list_list_1: Box<IdentListList>,
}

/// Type derived for non-terminal IdentListList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct IdentListList {
    vec: Vec<(OwnedToken /* , */, Ident)>,
}

/// Type derived for non-terminal IfPrefix
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct IfPrefix {
    i_f_0: OwnedToken, /* IF */
    expression_1: Box<Expression>,
    t_h_e_n_2: OwnedToken, /* THEN */
    statement_sequence_3: Box<StatementSequence>,
    if_prefix_list_4: Box<IfPrefixList>,
}

/// Type derived for non-terminal IfPrefixList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct IfPrefixList {
    vec: Vec<(
        OwnedToken, /* ELSIF */
        Expression,
        OwnedToken, /* THEN */
        StatementSequence,
    )>,
}

/// Type derived for non-terminal IfStatement
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct IfStatement {
    if_prefix_0: Box<IfPrefix>,
    if_statement_suffix_1: Box<IfStatementSuffix>,
}

/// Type derived for non-terminal IfStatementOpt
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct IfStatementOpt {
    e_l_s_e_0: OwnedToken, /* ELSE */
    statement_sequence_1: Box<StatementSequence>,
}

/// Type derived for non-terminal IfStatementSuffix
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum IfStatementSuffix {
    IfStatementSuffix0(Box<IfStatementSuffix39>),
    IfStatementSuffix1(Box<IfStatementSuffix40>),
}

/// Type derived for non-terminal Integer
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Integer {
    integer_0: OwnedToken, /* [0-9]+ */
}

/// Type derived for non-terminal MulExpression
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct MulExpression {
    mul_expression_list_0: Box<MulExpressionList>,
}

/// Type derived for non-terminal MulExpressionList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct MulExpressionList {
    vec: Vec<(MulOperator, Factor)>,
}

/// Type derived for non-terminal MulOperator
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct MulOperator {
    mul_operator_0: OwnedToken, /* \*|/|DIV|MOD|& */
}

/// Type derived for non-terminal ProcedureBody
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureBody {
    declarations_0: Box<Declarations>,
    procedure_body_suffix1_1: Box<ProcedureBodySuffix1>,
}

/// Type derived for non-terminal ProcedureBodySuffix
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum ProcedureBodySuffix {
    ProcedureBodySuffix0(Box<ProcedureBodySuffix92>),
    ProcedureBodySuffix1(Box<ProcedureBodySuffix93>),
}

/// Type derived for non-terminal ProcedureBodySuffix1
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum ProcedureBodySuffix1 {
    ProcedureBodySuffix1_0(Box<ProcedureBodySuffix1_89>),
    ProcedureBodySuffix1_1(Box<ProcedureBodySuffix1_90>),
    ProcedureBodySuffix1_2(Box<ProcedureBodySuffix1_91>),
}

/// Type derived for non-terminal ProcedureCall
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureCall {
    ident_0: Box<Ident>,
    procedure_call_suffix_1: Box<ProcedureCallSuffix>,
}

/// Type derived for non-terminal ProcedureCallOpt
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureCallOpt {
    actual_parameters_0: Box<ActualParameters>,
}

/// Type derived for non-terminal ProcedureCallSuffix
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureCallSuffix {
    opt: Option<Box<ProcedureCallOpt>>,
}

/// Type derived for non-terminal ProcedureDeclaration
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureDeclaration {
    procedure_heading_0: Box<ProcedureHeading>,
    semicolon_1: OwnedToken, /* ; */
    procedure_body_2: Box<ProcedureBody>,
}

/// Type derived for non-terminal ProcedureDeclarationList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureDeclarationList {
    procedure_declaration_list_list_0: Box<ProcedureDeclarationListList>,
}

/// Type derived for non-terminal ProcedureDeclarationListList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureDeclarationListList {
    vec: Vec<(ProcedureDeclaration, OwnedToken /* ; */)>,
}

/// Type derived for non-terminal ProcedureHeading
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureHeading {
    p_r_o_c_e_d_u_r_e_0: OwnedToken, /* PROCEDURE */
    ident_1: Box<Ident>,
    procedure_heading_suffix_2: Box<ProcedureHeadingSuffix>,
}

/// Type derived for non-terminal ProcedureHeadingOpt
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureHeadingOpt {
    formal_parameters_0: Box<FormalParameters>,
}

/// Type derived for non-terminal ProcedureHeadingSuffix
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ProcedureHeadingSuffix {
    opt: Option<Box<ProcedureHeadingOpt>>,
}

/// Type derived for non-terminal RecordType
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RecordType {
    r_e_c_o_r_d_0: OwnedToken, /* RECORD */
    record_type_suffix_1: Box<RecordTypeSuffix>,
}

/// Type derived for non-terminal RecordTypeList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RecordTypeList {
    vec: Vec<OwnedToken /* ; */>,
}

/// Type derived for non-terminal RecordTypeListSuffix
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum RecordTypeListSuffix {
    RecordTypeListSuffix0(Box<RecordTypeListSuffix69>),
    RecordTypeListSuffix1(Box<RecordTypeListSuffix70>),
}

/// Type derived for non-terminal RecordTypeOpt
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RecordTypeOpt {
    field_list_0: Box<FieldList>,
}

/// Type derived for non-terminal RecordTypeSuffix
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum RecordTypeSuffix {
    RecordTypeSuffix0(Box<RecordTypeSuffix65>),
    RecordTypeSuffix1(Box<RecordTypeSuffix66>),
}

/// Type derived for non-terminal RelationOp
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum RelationOp {
    RelationOp0(Box<RelationOp19>),
    RelationOp1(Box<RelationOp20>),
}

/// Type derived for non-terminal RelationalOps
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RelationalOps {
    relational_ops_0: OwnedToken, /* >=|<=|\#|<|> */
}

/// Type derived for non-terminal RepeatStatement
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct RepeatStatement {
    r_e_p_e_a_t_0: OwnedToken, /* REPEAT */
    statement_sequence_1: Box<StatementSequence>,
    u_n_t_i_l_2: OwnedToken, /* UNTIL */
    expression_3: Box<Expression>,
}

/// Type derived for non-terminal Selector
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Selector {
    selector_list_0: Box<SelectorList>,
}

/// Type derived for non-terminal SelectorList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct SelectorList {
    vec: Vec<SelectorListGroup>,
}

/// Type derived for non-terminal SelectorListGroup
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum SelectorListGroup {
    SelectorListGroup0(Box<SelectorListGroup2>),
    SelectorListGroup1(Box<SelectorListGroup3>),
}

/// Type derived for non-terminal SimpleExpression
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct SimpleExpression {
    term_0: Box<Term>,
    add_expression_1: Box<AddExpression>,
}

/// Type derived for non-terminal Statement
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum Statement {
    Statement0(Box<Statement47>),
    Statement1(Box<Statement48>),
    Statement2(Box<Statement49>),
    Statement3(Box<Statement50>),
    Statement4(Box<Statement51>),
}

/// Type derived for non-terminal StatementSequence
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum StatementSequence {
    StatementSequence0(Box<StatementSequence52>),
    StatementSequence1(Box<StatementSequence53>),
}

/// Type derived for non-terminal StatementSequenceList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StatementSequenceList {
    vec: Vec<OwnedToken /* ; */>,
}

/// Type derived for non-terminal StatementSequenceListSuffix
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum StatementSequenceListSuffix {
    StatementSequenceListSuffix0(Box<StatementSequenceListSuffix56>),
    StatementSequenceListSuffix1(Box<StatementSequenceListSuffix57>),
}

/// Type derived for non-terminal StatementSequenceOpt
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StatementSequenceOpt {
    statement_0: Box<Statement>,
}

/// Type derived for non-terminal Term
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Term {
    factor_0: Box<Factor>,
    mul_expression_1: Box<MulExpression>,
}

/// Type derived for non-terminal Type
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum Type {
    Type0(Box<Type72>),
    Type1(Box<Type73>),
    Type2(Box<Type74>),
}

/// Type derived for non-terminal TypeDecls
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct TypeDecls {
    type_decls_list_0: Box<TypeDeclsList>,
}

/// Type derived for non-terminal TypeDeclsList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct TypeDeclsList {
    vec: Vec<(Ident, AssignOp, Type, OwnedToken /* ; */)>,
}

/// Type derived for non-terminal UnaryOp
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct UnaryOp {
    unary_op_0: OwnedToken, /* \+|- */
}

/// Type derived for non-terminal VarDecls
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct VarDecls {
    var_decls_list_0: Box<VarDeclsList>,
}

/// Type derived for non-terminal VarDeclsList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct VarDeclsList {
    vec: Vec<(
        IdentList,
        OwnedToken, /* : */
        Type,
        OwnedToken, /* ; */
    )>,
}

/// Type derived for non-terminal WhileStatement
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct WhileStatement {
    w_h_i_l_e_0: OwnedToken, /* WHILE */
    expression_1: Box<Expression>,
    d_o_2: OwnedToken, /* DO */
    statement_sequence_3: Box<StatementSequence>,
    e_n_d_4: OwnedToken, /* END */
}

/// Type derived for non-terminal declarations
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum Declarations {
    Declarations0(Box<Declarations95>),
    Declarations1(Box<Declarations96>),
    Declarations2(Box<Declarations99>),
    Declarations3(Box<Declarations100>),
}

/// Type derived for non-terminal declarationsOpt
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct DeclarationsOpt {
    f_p_section_opt_0: OwnedToken, /* VAR */
    var_decls_1: Box<VarDecls>,
}

/// Type derived for non-terminal declarationsSuffix
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum DeclarationsSuffix {
    DeclarationsSuffix0(Box<DeclarationsSuffix104>),
    DeclarationsSuffix1(Box<DeclarationsSuffix105>),
}

/// Type derived for non-terminal declarationsSuffix1
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum DeclarationsSuffix1 {
    DeclarationsSuffix1_0(Box<DeclarationsSuffix1_101>),
    DeclarationsSuffix1_1(Box<DeclarationsSuffix1_102>),
    DeclarationsSuffix1_2(Box<DeclarationsSuffix1_103>),
}

/// Type derived for non-terminal declarationsSuffix2
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum DeclarationsSuffix2 {
    DeclarationsSuffix2_0(Box<DeclarationsSuffix2_97>),
    DeclarationsSuffix2_1(Box<DeclarationsSuffix2_98>),
}

/// Type derived for non-terminal module
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Module {
    m_o_d_u_l_e_0: OwnedToken, /* MODULE */
    ident_1: Box<Ident>,
    semicolon_2: OwnedToken, /* ; */
    declarations_3: Box<Declarations>,
    module_suffix_4: Box<ModuleSuffix>,
}

/// Type derived for non-terminal moduleOpt
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ModuleOpt {
    b_e_g_i_n_0: OwnedToken, /* BEGIN */
    statement_sequence_1: Box<StatementSequence>,
}

/// Type derived for non-terminal moduleSuffix
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum ModuleSuffix {
    ModuleSuffix0(Box<ModuleSuffix120>),
    ModuleSuffix1(Box<ModuleSuffix121>),
}

//
// AST type of the transformed grammar
//

/// Derived from production output types
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum ASTType {
    ActualParameters(ActualParameters),
    ActualParametersOpt(ActualParametersOpt),
    ActualParametersOptList(ActualParametersOptList),
    ActualParametersSuffix(ActualParametersSuffix),
    AddExpression(AddExpression),
    AddExpressionList(AddExpressionList),
    AddOperator(AddOperator),
    ArrayType(ArrayType),
    AssignOp(AssignOp),
    Assignment(Assignment),
    ConstDecls(ConstDecls),
    ConstDeclsList(ConstDeclsList),
    Expression(Expression),
    ExpressionOpt(ExpressionOpt),
    ExpressionSuffix(ExpressionSuffix),
    FPSection(FPSection),
    FPSectionOpt(FPSectionOpt),
    Factor(Factor),
    FieldList(FieldList),
    FormalParameters(FormalParameters),
    FormalParametersOpt(FormalParametersOpt),
    FormalParametersOptList(FormalParametersOptList),
    FormalParametersSuffix(FormalParametersSuffix),
    Ident(Ident),
    IdentList(IdentList),
    IdentListList(IdentListList),
    IfPrefix(IfPrefix),
    IfPrefixList(IfPrefixList),
    IfStatement(IfStatement),
    IfStatementOpt(IfStatementOpt),
    IfStatementSuffix(IfStatementSuffix),
    Integer(Integer),
    MulExpression(MulExpression),
    MulExpressionList(MulExpressionList),
    MulOperator(MulOperator),
    ProcedureBody(ProcedureBody),
    ProcedureBodySuffix(ProcedureBodySuffix),
    ProcedureBodySuffix1(ProcedureBodySuffix1),
    ProcedureCall(ProcedureCall),
    ProcedureCallOpt(ProcedureCallOpt),
    ProcedureCallSuffix(ProcedureCallSuffix),
    ProcedureDeclaration(ProcedureDeclaration),
    ProcedureDeclarationList(ProcedureDeclarationList),
    ProcedureDeclarationListList(ProcedureDeclarationListList),
    ProcedureHeading(ProcedureHeading),
    ProcedureHeadingOpt(ProcedureHeadingOpt),
    ProcedureHeadingSuffix(ProcedureHeadingSuffix),
    RecordType(RecordType),
    RecordTypeList(RecordTypeList),
    RecordTypeListSuffix(RecordTypeListSuffix),
    RecordTypeOpt(RecordTypeOpt),
    RecordTypeSuffix(RecordTypeSuffix),
    RelationOp(RelationOp),
    RelationalOps(RelationalOps),
    RepeatStatement(RepeatStatement),
    Selector(Selector),
    SelectorList(SelectorList),
    SelectorListGroup(SelectorListGroup),
    SimpleExpression(SimpleExpression),
    Statement(Statement),
    StatementSequence(StatementSequence),
    StatementSequenceList(StatementSequenceList),
    StatementSequenceListSuffix(StatementSequenceListSuffix),
    StatementSequenceOpt(StatementSequenceOpt),
    Term(Term),
    Type(Type),
    TypeDecls(TypeDecls),
    TypeDeclsList(TypeDeclsList),
    UnaryOp(UnaryOp),
    VarDecls(VarDecls),
    VarDeclsList(VarDeclsList),
    WhileStatement(WhileStatement),
    Declarations(Declarations),
    DeclarationsOpt(DeclarationsOpt),
    DeclarationsSuffix(DeclarationsSuffix),
    DeclarationsSuffix1(DeclarationsSuffix1),
    DeclarationsSuffix2(DeclarationsSuffix2),
    Module(Module),
    ModuleOpt(ModuleOpt),
    ModuleSuffix(ModuleSuffix),
}

///
/// The `Oberon0GrammarTrait` trait is automatically generated for the
/// given grammar.
/// All functions have default implementations.
///
pub trait Oberon0GrammarTrait {
    ///
    /// Implement this method if you need the provided information
    ///
    fn init(&mut self, _file_name: &std::path::Path) {}

    /// Semantic action for production 0:
    ///
    /// Selector: SelectorList;
    ///
    fn selector_0(
        &mut self,
        _selector_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// SelectorList: SelectorListGroup SelectorList;
    ///
    fn selector_list_1(
        &mut self,
        _selector_list_group_0: &ParseTreeStackEntry,
        _selector_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// SelectorListGroup: "\." Ident;
    ///
    fn selector_list_group_2(
        &mut self,
        _dot_0: &ParseTreeStackEntry,
        _ident_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// SelectorListGroup: "\[" Expression "]";
    ///
    fn selector_list_group_3(
        &mut self,
        _l_bracket_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _r_bracket_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// SelectorList: /* Vec<SelectorList>::New */;
    ///
    fn selector_list_4(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// Factor: Ident Selector;
    ///
    fn factor_5(
        &mut self,
        _ident_0: &ParseTreeStackEntry,
        _selector_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// Factor: Integer;
    ///
    fn factor_6(
        &mut self,
        _integer_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// Factor: "\(" Expression "\)";
    ///
    fn factor_7(
        &mut self,
        _l_paren_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _r_paren_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// Factor: "~" Factor;
    ///
    fn factor_8(
        &mut self,
        _tilde_0: &ParseTreeStackEntry,
        _factor_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// Factor: UnaryOp Factor;
    ///
    fn factor_9(
        &mut self,
        _unary_op_0: &ParseTreeStackEntry,
        _factor_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// Term: Factor MulExpression;
    ///
    fn term_10(
        &mut self,
        _factor_0: &ParseTreeStackEntry,
        _mul_expression_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// MulExpression: MulExpressionList;
    ///
    fn mul_expression_11(
        &mut self,
        _mul_expression_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// MulExpressionList: MulOperator Factor MulExpressionList;
    ///
    fn mul_expression_list_12(
        &mut self,
        _mul_operator_0: &ParseTreeStackEntry,
        _factor_1: &ParseTreeStackEntry,
        _mul_expression_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// MulExpressionList: /* Vec<MulExpressionList>::New */;
    ///
    fn mul_expression_list_13(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// SimpleExpression: Term AddExpression;
    ///
    fn simple_expression_14(
        &mut self,
        _term_0: &ParseTreeStackEntry,
        _add_expression_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// AddExpression: AddExpressionList;
    ///
    fn add_expression_15(
        &mut self,
        _add_expression_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// AddExpressionList: AddOperator Term AddExpressionList;
    ///
    fn add_expression_list_16(
        &mut self,
        _add_operator_0: &ParseTreeStackEntry,
        _term_1: &ParseTreeStackEntry,
        _add_expression_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// AddExpressionList: /* Vec<AddExpressionList>::New */;
    ///
    fn add_expression_list_17(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// AssignOp: ":=";
    ///
    fn assign_op_18(
        &mut self,
        _colon_equ_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// RelationOp: AssignOp;
    ///
    fn relation_op_19(
        &mut self,
        _assign_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// RelationOp: RelationalOps;
    ///
    fn relation_op_20(
        &mut self,
        _relational_ops_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// RelationalOps: ">=|<=|\#|<|>";
    ///
    fn relational_ops_21(
        &mut self,
        _relational_ops_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// AssignOp: "=";
    ///
    fn assign_op_22(
        &mut self,
        _equ_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// Expression: SimpleExpression ExpressionSuffix;
    ///
    fn expression_23(
        &mut self,
        _simple_expression_0: &ParseTreeStackEntry,
        _expression_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// ExpressionSuffix: ExpressionOpt;
    ///
    fn expression_suffix_24(
        &mut self,
        _expression_opt_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// ExpressionSuffix: /* Option<ExpressionOpt>::None */;
    ///
    fn expression_suffix_25(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// ExpressionOpt: RelationOp SimpleExpression;
    ///
    fn expression_opt_26(
        &mut self,
        _relation_op_0: &ParseTreeStackEntry,
        _simple_expression_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// Assignment: Ident Selector AssignOp Expression;
    ///
    fn assignment_27(
        &mut self,
        _ident_0: &ParseTreeStackEntry,
        _selector_1: &ParseTreeStackEntry,
        _assign_op_2: &ParseTreeStackEntry,
        _expression_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// ActualParameters: "\(" ActualParametersSuffix;
    ///
    fn actual_parameters_28(
        &mut self,
        _l_paren_0: &ParseTreeStackEntry,
        _actual_parameters_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// ActualParametersSuffix: ActualParametersOpt "\)";
    ///
    fn actual_parameters_suffix_29(
        &mut self,
        _actual_parameters_opt_0: &ParseTreeStackEntry,
        _r_paren_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// ActualParametersSuffix: /* Option<ActualParametersOpt>::None */ "\)";
    ///
    fn actual_parameters_suffix_30(
        &mut self,
        _r_paren_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// ActualParametersOpt: Expression ActualParametersOptList;
    ///
    fn actual_parameters_opt_31(
        &mut self,
        _expression_0: &ParseTreeStackEntry,
        _actual_parameters_opt_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// ActualParametersOptList: "," Expression ActualParametersOptList;
    ///
    fn actual_parameters_opt_list_32(
        &mut self,
        _comma_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _actual_parameters_opt_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// ActualParametersOptList: /* Vec<ActualParametersOptList>::New */;
    ///
    fn actual_parameters_opt_list_33(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// ProcedureCall: Ident ProcedureCallSuffix;
    ///
    fn procedure_call_34(
        &mut self,
        _ident_0: &ParseTreeStackEntry,
        _procedure_call_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// ProcedureCallSuffix: ProcedureCallOpt;
    ///
    fn procedure_call_suffix_35(
        &mut self,
        _procedure_call_opt_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// ProcedureCallSuffix: /* Option<ProcedureCallOpt>::None */;
    ///
    fn procedure_call_suffix_36(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// ProcedureCallOpt: ActualParameters;
    ///
    fn procedure_call_opt_37(
        &mut self,
        _actual_parameters_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// IfStatement: IfPrefix IfStatementSuffix;
    ///
    fn if_statement_38(
        &mut self,
        _if_prefix_0: &ParseTreeStackEntry,
        _if_statement_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// IfStatementSuffix: IfStatementOpt "END";
    ///
    fn if_statement_suffix_39(
        &mut self,
        _if_statement_opt_0: &ParseTreeStackEntry,
        _e_n_d_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// IfStatementSuffix: /* Option<IfStatementOpt>::None */ "END";
    ///
    fn if_statement_suffix_40(
        &mut self,
        _e_n_d_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// IfStatementOpt: "ELSE" StatementSequence;
    ///
    fn if_statement_opt_41(
        &mut self,
        _e_l_s_e_0: &ParseTreeStackEntry,
        _statement_sequence_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// IfPrefix: "IF" Expression "THEN" StatementSequence IfPrefixList;
    ///
    fn if_prefix_42(
        &mut self,
        _i_f_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _t_h_e_n_2: &ParseTreeStackEntry,
        _statement_sequence_3: &ParseTreeStackEntry,
        _if_prefix_list_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// IfPrefixList: "ELSIF" Expression "THEN" StatementSequence IfPrefixList;
    ///
    fn if_prefix_list_43(
        &mut self,
        _e_l_s_i_f_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _t_h_e_n_2: &ParseTreeStackEntry,
        _statement_sequence_3: &ParseTreeStackEntry,
        _if_prefix_list_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// IfPrefixList: /* Vec<IfPrefixList>::New */;
    ///
    fn if_prefix_list_44(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// WhileStatement: "WHILE" Expression "DO" StatementSequence "END";
    ///
    fn while_statement_45(
        &mut self,
        _w_h_i_l_e_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _d_o_2: &ParseTreeStackEntry,
        _statement_sequence_3: &ParseTreeStackEntry,
        _e_n_d_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// RepeatStatement: "REPEAT" StatementSequence "UNTIL" Expression;
    ///
    fn repeat_statement_46(
        &mut self,
        _r_e_p_e_a_t_0: &ParseTreeStackEntry,
        _statement_sequence_1: &ParseTreeStackEntry,
        _u_n_t_i_l_2: &ParseTreeStackEntry,
        _expression_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// Statement: Assignment;
    ///
    fn statement_47(
        &mut self,
        _assignment_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// Statement: ProcedureCall;
    ///
    fn statement_48(
        &mut self,
        _procedure_call_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// Statement: IfStatement;
    ///
    fn statement_49(
        &mut self,
        _if_statement_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// Statement: WhileStatement;
    ///
    fn statement_50(
        &mut self,
        _while_statement_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// Statement: RepeatStatement;
    ///
    fn statement_51(
        &mut self,
        _repeat_statement_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// StatementSequence: StatementSequenceOpt StatementSequenceList;
    ///
    fn statement_sequence_52(
        &mut self,
        _statement_sequence_opt_0: &ParseTreeStackEntry,
        _statement_sequence_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// StatementSequence: /* Option<StatementSequenceOpt>::None */ StatementSequenceList;
    ///
    fn statement_sequence_53(
        &mut self,
        _statement_sequence_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// StatementSequenceOpt: Statement;
    ///
    fn statement_sequence_opt_54(
        &mut self,
        _statement_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// StatementSequenceList: ";" StatementSequenceListSuffix;
    ///
    fn statement_sequence_list_55(
        &mut self,
        _semicolon_0: &ParseTreeStackEntry,
        _statement_sequence_list_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// StatementSequenceListSuffix: StatementSequenceOpt StatementSequenceList;
    ///
    fn statement_sequence_list_suffix_56(
        &mut self,
        _statement_sequence_opt_0: &ParseTreeStackEntry,
        _statement_sequence_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// StatementSequenceListSuffix: /* Option<StatementSequenceListOpt>::None */ StatementSequenceList;
    ///
    fn statement_sequence_list_suffix_57(
        &mut self,
        _statement_sequence_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// StatementSequenceList: /* Vec<StatementSequenceList>::New */;
    ///
    fn statement_sequence_list_58(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// IdentList: Ident IdentListList;
    ///
    fn ident_list_59(
        &mut self,
        _ident_0: &ParseTreeStackEntry,
        _ident_list_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// IdentListList: "," Ident IdentListList;
    ///
    fn ident_list_list_60(
        &mut self,
        _comma_0: &ParseTreeStackEntry,
        _ident_1: &ParseTreeStackEntry,
        _ident_list_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// IdentListList: /* Vec<IdentListList>::New */;
    ///
    fn ident_list_list_61(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// ArrayType: "ARRAY" Expression "OF" Type;
    ///
    fn array_type_62(
        &mut self,
        _a_r_r_a_y_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _o_f_2: &ParseTreeStackEntry,
        _type_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// FieldList: IdentList ":" Type;
    ///
    fn field_list_63(
        &mut self,
        _ident_list_0: &ParseTreeStackEntry,
        _colon_1: &ParseTreeStackEntry,
        _type_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// RecordType: "RECORD" RecordTypeSuffix;
    ///
    fn record_type_64(
        &mut self,
        _r_e_c_o_r_d_0: &ParseTreeStackEntry,
        _record_type_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// RecordTypeSuffix: RecordTypeOpt RecordTypeList "END";
    ///
    fn record_type_suffix_65(
        &mut self,
        _record_type_opt_0: &ParseTreeStackEntry,
        _record_type_list_1: &ParseTreeStackEntry,
        _e_n_d_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// RecordTypeSuffix: /* Option<RecordTypeOpt>::None */ RecordTypeList "END";
    ///
    fn record_type_suffix_66(
        &mut self,
        _record_type_list_1: &ParseTreeStackEntry,
        _e_n_d_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// RecordTypeOpt: FieldList;
    ///
    fn record_type_opt_67(
        &mut self,
        _field_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// RecordTypeList: ";" RecordTypeListSuffix;
    ///
    fn record_type_list_68(
        &mut self,
        _semicolon_0: &ParseTreeStackEntry,
        _record_type_list_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// RecordTypeListSuffix: RecordTypeOpt RecordTypeList;
    ///
    fn record_type_list_suffix_69(
        &mut self,
        _record_type_opt_0: &ParseTreeStackEntry,
        _record_type_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// RecordTypeListSuffix: /* Option<RecordTypeListOpt>::None */ RecordTypeList;
    ///
    fn record_type_list_suffix_70(
        &mut self,
        _record_type_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// RecordTypeList: /* Vec<RecordTypeList>::New */;
    ///
    fn record_type_list_71(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// Type: Ident;
    ///
    fn type_72(
        &mut self,
        _ident_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// Type: ArrayType;
    ///
    fn type_73(
        &mut self,
        _array_type_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// Type: RecordType;
    ///
    fn type_74(
        &mut self,
        _record_type_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// FPSection: FPSectionOpt IdentList ":" Type;
    ///
    fn f_p_section_75(
        &mut self,
        _f_p_section_opt_0: &ParseTreeStackEntry,
        _ident_list_1: &ParseTreeStackEntry,
        _colon_2: &ParseTreeStackEntry,
        _type_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// FPSection: /* Option<FPSectionOpt>::None */ IdentList ":" Type;
    ///
    fn f_p_section_76(
        &mut self,
        _ident_list_1: &ParseTreeStackEntry,
        _colon_2: &ParseTreeStackEntry,
        _type_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// FPSectionOpt: "VAR";
    ///
    fn f_p_section_opt_77(
        &mut self,
        _f_p_section_opt_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// FormalParameters: "\(" FormalParametersSuffix;
    ///
    fn formal_parameters_78(
        &mut self,
        _l_paren_0: &ParseTreeStackEntry,
        _formal_parameters_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// FormalParametersSuffix: FormalParametersOpt "\)";
    ///
    fn formal_parameters_suffix_79(
        &mut self,
        _formal_parameters_opt_0: &ParseTreeStackEntry,
        _r_paren_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// FormalParametersSuffix: /* Option<FormalParametersOpt>::None */ "\)";
    ///
    fn formal_parameters_suffix_80(
        &mut self,
        _r_paren_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// FormalParametersOpt: FPSection FormalParametersOptList;
    ///
    fn formal_parameters_opt_81(
        &mut self,
        _f_p_section_0: &ParseTreeStackEntry,
        _formal_parameters_opt_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// FormalParametersOptList: ";" FPSection FormalParametersOptList;
    ///
    fn formal_parameters_opt_list_82(
        &mut self,
        _semicolon_0: &ParseTreeStackEntry,
        _f_p_section_1: &ParseTreeStackEntry,
        _formal_parameters_opt_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// FormalParametersOptList: /* Vec<FormalParametersOptList>::New */;
    ///
    fn formal_parameters_opt_list_83(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// ProcedureHeading: "PROCEDURE" Ident ProcedureHeadingSuffix;
    ///
    fn procedure_heading_84(
        &mut self,
        _p_r_o_c_e_d_u_r_e_0: &ParseTreeStackEntry,
        _ident_1: &ParseTreeStackEntry,
        _procedure_heading_suffix_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// ProcedureHeadingSuffix: ProcedureHeadingOpt;
    ///
    fn procedure_heading_suffix_85(
        &mut self,
        _procedure_heading_opt_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// ProcedureHeadingSuffix: /* Option<ProcedureHeadingOpt>::None */;
    ///
    fn procedure_heading_suffix_86(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// ProcedureHeadingOpt: FormalParameters;
    ///
    fn procedure_heading_opt_87(
        &mut self,
        _formal_parameters_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// ProcedureBody: declarations ProcedureBodySuffix1;
    ///
    fn procedure_body_88(
        &mut self,
        _declarations_0: &ParseTreeStackEntry,
        _procedure_body_suffix1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// ProcedureBodySuffix1: "BEGIN" StatementSequence ProcedureBodySuffix;
    ///
    fn procedure_body_suffix1_89(
        &mut self,
        _b_e_g_i_n_0: &ParseTreeStackEntry,
        _statement_sequence_1: &ParseTreeStackEntry,
        _procedure_body_suffix_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// ProcedureBodySuffix1: "RETURN" Expression "END" Ident;
    ///
    fn procedure_body_suffix1_90(
        &mut self,
        _r_e_t_u_r_n_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _e_n_d_2: &ParseTreeStackEntry,
        _ident_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// ProcedureBodySuffix1: "END" Ident;
    ///
    fn procedure_body_suffix1_91(
        &mut self,
        _e_n_d_0: &ParseTreeStackEntry,
        _ident_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// ProcedureBodySuffix: "RETURN" Expression "END" Ident;
    ///
    fn procedure_body_suffix_92(
        &mut self,
        _r_e_t_u_r_n_0: &ParseTreeStackEntry,
        _expression_1: &ParseTreeStackEntry,
        _e_n_d_2: &ParseTreeStackEntry,
        _ident_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// ProcedureBodySuffix: "END" Ident;
    ///
    fn procedure_body_suffix_93(
        &mut self,
        _e_n_d_0: &ParseTreeStackEntry,
        _ident_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// ProcedureDeclaration: ProcedureHeading ";" ProcedureBody;
    ///
    fn procedure_declaration_94(
        &mut self,
        _procedure_heading_0: &ParseTreeStackEntry,
        _semicolon_1: &ParseTreeStackEntry,
        _procedure_body_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// declarations: "Type" TypeDecls declarationsSuffix2;
    ///
    fn declarations_95(
        &mut self,
        _type_0: &ParseTreeStackEntry,
        _type_decls_1: &ParseTreeStackEntry,
        _declarations_suffix2_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// declarations: "CONST" ConstDecls declarationsSuffix1;
    ///
    fn declarations_96(
        &mut self,
        _c_o_n_s_t_0: &ParseTreeStackEntry,
        _const_decls_1: &ParseTreeStackEntry,
        _declarations_suffix1_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// declarationsSuffix2: declarationsOpt ProcedureDeclarationList;
    ///
    fn declarations_suffix2_97(
        &mut self,
        _declarations_opt_0: &ParseTreeStackEntry,
        _procedure_declaration_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// declarationsSuffix2: /* Option<declarationsOpt2>::None */ ProcedureDeclarationList;
    ///
    fn declarations_suffix2_98(
        &mut self,
        _procedure_declaration_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// declarations: "VAR" VarDecls ProcedureDeclarationList;
    ///
    fn declarations_99(
        &mut self,
        _f_p_section_opt_0: &ParseTreeStackEntry,
        _var_decls_1: &ParseTreeStackEntry,
        _procedure_declaration_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// declarations: ProcedureDeclarationList;
    ///
    fn declarations_100(
        &mut self,
        _procedure_declaration_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// declarationsSuffix1: "Type" TypeDecls declarationsSuffix;
    ///
    fn declarations_suffix1_101(
        &mut self,
        _type_0: &ParseTreeStackEntry,
        _type_decls_1: &ParseTreeStackEntry,
        _declarations_suffix_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// declarationsSuffix1: declarationsOpt ProcedureDeclarationList;
    ///
    fn declarations_suffix1_102(
        &mut self,
        _declarations_opt_0: &ParseTreeStackEntry,
        _procedure_declaration_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// declarationsSuffix1: /* Option<declarationsOpt1>::None */ ProcedureDeclarationList;
    ///
    fn declarations_suffix1_103(
        &mut self,
        _procedure_declaration_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// declarationsSuffix: declarationsOpt ProcedureDeclarationList;
    ///
    fn declarations_suffix_104(
        &mut self,
        _declarations_opt_0: &ParseTreeStackEntry,
        _procedure_declaration_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// declarationsSuffix: /* Option<declarationsOpt>::None */ ProcedureDeclarationList;
    ///
    fn declarations_suffix_105(
        &mut self,
        _procedure_declaration_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// declarationsOpt: "VAR" VarDecls;
    ///
    fn declarations_opt_106(
        &mut self,
        _f_p_section_opt_0: &ParseTreeStackEntry,
        _var_decls_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// ProcedureDeclarationList: ProcedureDeclarationListList;
    ///
    fn procedure_declaration_list_107(
        &mut self,
        _procedure_declaration_list_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// ProcedureDeclarationListList: ProcedureDeclaration ";" ProcedureDeclarationListList;
    ///
    fn procedure_declaration_list_list_108(
        &mut self,
        _procedure_declaration_0: &ParseTreeStackEntry,
        _semicolon_1: &ParseTreeStackEntry,
        _procedure_declaration_list_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// ProcedureDeclarationListList: /* Vec<ProcedureDeclarationListList>::New */;
    ///
    fn procedure_declaration_list_list_109(
        &mut self,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// ConstDecls: ConstDeclsList;
    ///
    fn const_decls_110(
        &mut self,
        _const_decls_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// ConstDeclsList: Ident AssignOp Expression ";" ConstDeclsList;
    ///
    fn const_decls_list_111(
        &mut self,
        _ident_0: &ParseTreeStackEntry,
        _assign_op_1: &ParseTreeStackEntry,
        _expression_2: &ParseTreeStackEntry,
        _semicolon_3: &ParseTreeStackEntry,
        _const_decls_list_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// ConstDeclsList: /* Vec<ConstDeclsList>::New */;
    ///
    fn const_decls_list_112(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// TypeDecls: TypeDeclsList;
    ///
    fn type_decls_113(
        &mut self,
        _type_decls_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// TypeDeclsList: Ident AssignOp Type ";" TypeDeclsList;
    ///
    fn type_decls_list_114(
        &mut self,
        _ident_0: &ParseTreeStackEntry,
        _assign_op_1: &ParseTreeStackEntry,
        _type_2: &ParseTreeStackEntry,
        _semicolon_3: &ParseTreeStackEntry,
        _type_decls_list_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// TypeDeclsList: /* Vec<TypeDeclsList>::New */;
    ///
    fn type_decls_list_115(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// VarDecls: VarDeclsList;
    ///
    fn var_decls_116(
        &mut self,
        _var_decls_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// VarDeclsList: IdentList ":" Type ";" VarDeclsList;
    ///
    fn var_decls_list_117(
        &mut self,
        _ident_list_0: &ParseTreeStackEntry,
        _colon_1: &ParseTreeStackEntry,
        _type_2: &ParseTreeStackEntry,
        _semicolon_3: &ParseTreeStackEntry,
        _var_decls_list_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// VarDeclsList: /* Vec<VarDeclsList>::New */;
    ///
    fn var_decls_list_118(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// module: "MODULE" Ident ";" declarations moduleSuffix;
    ///
    fn module_119(
        &mut self,
        _m_o_d_u_l_e_0: &ParseTreeStackEntry,
        _ident_1: &ParseTreeStackEntry,
        _semicolon_2: &ParseTreeStackEntry,
        _declarations_3: &ParseTreeStackEntry,
        _module_suffix_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// moduleSuffix: moduleOpt "END" Ident "\.";
    ///
    fn module_suffix_120(
        &mut self,
        _module_opt_0: &ParseTreeStackEntry,
        _e_n_d_1: &ParseTreeStackEntry,
        _ident_2: &ParseTreeStackEntry,
        _dot_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// moduleSuffix: /* Option<moduleOpt>::None */ "END" Ident "\.";
    ///
    fn module_suffix_121(
        &mut self,
        _e_n_d_1: &ParseTreeStackEntry,
        _ident_2: &ParseTreeStackEntry,
        _dot_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// moduleOpt: "BEGIN" StatementSequence;
    ///
    fn module_opt_122(
        &mut self,
        _b_e_g_i_n_0: &ParseTreeStackEntry,
        _statement_sequence_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// MulOperator: "\*|/|DIV|MOD|&";
    ///
    fn mul_operator_123(
        &mut self,
        _mul_operator_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// AddOperator: "\+|-|OR";
    ///
    fn add_operator_124(
        &mut self,
        _add_operator_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// UnaryOp: "\+|-";
    ///
    fn unary_op_125(
        &mut self,
        _unary_op_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// Ident: "[a-zA-Z][a-zA-Z0-9]*";
    ///
    fn ident_126(
        &mut self,
        _ident_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// Integer: "[0-9]+";
    ///
    fn integer_127(
        &mut self,
        _integer_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }
}

impl UserActionsTrait for Oberon0Grammar {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// Is is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &std::path::Path) {
        Oberon0GrammarTrait::init(self, file_name);
    }

    ///
    /// This function is implemented automatically for the user's item Oberon0Grammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry],
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        match prod_num {
            0 => self.selector_0(&children[0], parse_tree),

            1 => self.selector_list_1(&children[0], &children[1], parse_tree),

            2 => self.selector_list_group_2(&children[0], &children[1], parse_tree),

            3 => self.selector_list_group_3(&children[0], &children[1], &children[2], parse_tree),

            4 => self.selector_list_4(parse_tree),

            5 => self.factor_5(&children[0], &children[1], parse_tree),

            6 => self.factor_6(&children[0], parse_tree),

            7 => self.factor_7(&children[0], &children[1], &children[2], parse_tree),

            8 => self.factor_8(&children[0], &children[1], parse_tree),

            9 => self.factor_9(&children[0], &children[1], parse_tree),

            10 => self.term_10(&children[0], &children[1], parse_tree),

            11 => self.mul_expression_11(&children[0], parse_tree),

            12 => self.mul_expression_list_12(&children[0], &children[1], &children[2], parse_tree),

            13 => self.mul_expression_list_13(parse_tree),

            14 => self.simple_expression_14(&children[0], &children[1], parse_tree),

            15 => self.add_expression_15(&children[0], parse_tree),

            16 => self.add_expression_list_16(&children[0], &children[1], &children[2], parse_tree),

            17 => self.add_expression_list_17(parse_tree),

            18 => self.assign_op_18(&children[0], parse_tree),

            19 => self.relation_op_19(&children[0], parse_tree),

            20 => self.relation_op_20(&children[0], parse_tree),

            21 => self.relational_ops_21(&children[0], parse_tree),

            22 => self.assign_op_22(&children[0], parse_tree),

            23 => self.expression_23(&children[0], &children[1], parse_tree),

            24 => self.expression_suffix_24(&children[0], parse_tree),

            25 => self.expression_suffix_25(parse_tree),

            26 => self.expression_opt_26(&children[0], &children[1], parse_tree),

            27 => self.assignment_27(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            28 => self.actual_parameters_28(&children[0], &children[1], parse_tree),

            29 => self.actual_parameters_suffix_29(&children[0], &children[1], parse_tree),

            30 => self.actual_parameters_suffix_30(&children[0], parse_tree),

            31 => self.actual_parameters_opt_31(&children[0], &children[1], parse_tree),

            32 => self.actual_parameters_opt_list_32(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),

            33 => self.actual_parameters_opt_list_33(parse_tree),

            34 => self.procedure_call_34(&children[0], &children[1], parse_tree),

            35 => self.procedure_call_suffix_35(&children[0], parse_tree),

            36 => self.procedure_call_suffix_36(parse_tree),

            37 => self.procedure_call_opt_37(&children[0], parse_tree),

            38 => self.if_statement_38(&children[0], &children[1], parse_tree),

            39 => self.if_statement_suffix_39(&children[0], &children[1], parse_tree),

            40 => self.if_statement_suffix_40(&children[0], parse_tree),

            41 => self.if_statement_opt_41(&children[0], &children[1], parse_tree),

            42 => self.if_prefix_42(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),

            43 => self.if_prefix_list_43(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),

            44 => self.if_prefix_list_44(parse_tree),

            45 => self.while_statement_45(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),

            46 => self.repeat_statement_46(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            47 => self.statement_47(&children[0], parse_tree),

            48 => self.statement_48(&children[0], parse_tree),

            49 => self.statement_49(&children[0], parse_tree),

            50 => self.statement_50(&children[0], parse_tree),

            51 => self.statement_51(&children[0], parse_tree),

            52 => self.statement_sequence_52(&children[0], &children[1], parse_tree),

            53 => self.statement_sequence_53(&children[0], parse_tree),

            54 => self.statement_sequence_opt_54(&children[0], parse_tree),

            55 => self.statement_sequence_list_55(&children[0], &children[1], parse_tree),

            56 => self.statement_sequence_list_suffix_56(&children[0], &children[1], parse_tree),

            57 => self.statement_sequence_list_suffix_57(&children[0], parse_tree),

            58 => self.statement_sequence_list_58(parse_tree),

            59 => self.ident_list_59(&children[0], &children[1], parse_tree),

            60 => self.ident_list_list_60(&children[0], &children[1], &children[2], parse_tree),

            61 => self.ident_list_list_61(parse_tree),

            62 => self.array_type_62(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            63 => self.field_list_63(&children[0], &children[1], &children[2], parse_tree),

            64 => self.record_type_64(&children[0], &children[1], parse_tree),

            65 => self.record_type_suffix_65(&children[0], &children[1], &children[2], parse_tree),

            66 => self.record_type_suffix_66(&children[0], &children[1], parse_tree),

            67 => self.record_type_opt_67(&children[0], parse_tree),

            68 => self.record_type_list_68(&children[0], &children[1], parse_tree),

            69 => self.record_type_list_suffix_69(&children[0], &children[1], parse_tree),

            70 => self.record_type_list_suffix_70(&children[0], parse_tree),

            71 => self.record_type_list_71(parse_tree),

            72 => self.type_72(&children[0], parse_tree),

            73 => self.type_73(&children[0], parse_tree),

            74 => self.type_74(&children[0], parse_tree),

            75 => self.f_p_section_75(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            76 => self.f_p_section_76(&children[0], &children[1], &children[2], parse_tree),

            77 => self.f_p_section_opt_77(&children[0], parse_tree),

            78 => self.formal_parameters_78(&children[0], &children[1], parse_tree),

            79 => self.formal_parameters_suffix_79(&children[0], &children[1], parse_tree),

            80 => self.formal_parameters_suffix_80(&children[0], parse_tree),

            81 => self.formal_parameters_opt_81(&children[0], &children[1], parse_tree),

            82 => self.formal_parameters_opt_list_82(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),

            83 => self.formal_parameters_opt_list_83(parse_tree),

            84 => self.procedure_heading_84(&children[0], &children[1], &children[2], parse_tree),

            85 => self.procedure_heading_suffix_85(&children[0], parse_tree),

            86 => self.procedure_heading_suffix_86(parse_tree),

            87 => self.procedure_heading_opt_87(&children[0], parse_tree),

            88 => self.procedure_body_88(&children[0], &children[1], parse_tree),

            89 => {
                self.procedure_body_suffix1_89(&children[0], &children[1], &children[2], parse_tree)
            }

            90 => self.procedure_body_suffix1_90(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            91 => self.procedure_body_suffix1_91(&children[0], &children[1], parse_tree),

            92 => self.procedure_body_suffix_92(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            93 => self.procedure_body_suffix_93(&children[0], &children[1], parse_tree),

            94 => {
                self.procedure_declaration_94(&children[0], &children[1], &children[2], parse_tree)
            }

            95 => self.declarations_95(&children[0], &children[1], &children[2], parse_tree),

            96 => self.declarations_96(&children[0], &children[1], &children[2], parse_tree),

            97 => self.declarations_suffix2_97(&children[0], &children[1], parse_tree),

            98 => self.declarations_suffix2_98(&children[0], parse_tree),

            99 => self.declarations_99(&children[0], &children[1], &children[2], parse_tree),

            100 => self.declarations_100(&children[0], parse_tree),

            101 => {
                self.declarations_suffix1_101(&children[0], &children[1], &children[2], parse_tree)
            }

            102 => self.declarations_suffix1_102(&children[0], &children[1], parse_tree),

            103 => self.declarations_suffix1_103(&children[0], parse_tree),

            104 => self.declarations_suffix_104(&children[0], &children[1], parse_tree),

            105 => self.declarations_suffix_105(&children[0], parse_tree),

            106 => self.declarations_opt_106(&children[0], &children[1], parse_tree),

            107 => self.procedure_declaration_list_107(&children[0], parse_tree),

            108 => self.procedure_declaration_list_list_108(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),

            109 => self.procedure_declaration_list_list_109(parse_tree),

            110 => self.const_decls_110(&children[0], parse_tree),

            111 => self.const_decls_list_111(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),

            112 => self.const_decls_list_112(parse_tree),

            113 => self.type_decls_113(&children[0], parse_tree),

            114 => self.type_decls_list_114(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),

            115 => self.type_decls_list_115(parse_tree),

            116 => self.var_decls_116(&children[0], parse_tree),

            117 => self.var_decls_list_117(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),

            118 => self.var_decls_list_118(parse_tree),

            119 => self.module_119(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),

            120 => self.module_suffix_120(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            121 => self.module_suffix_121(&children[0], &children[1], &children[2], parse_tree),

            122 => self.module_opt_122(&children[0], &children[1], parse_tree),

            123 => self.mul_operator_123(&children[0], parse_tree),

            124 => self.add_operator_124(&children[0], parse_tree),

            125 => self.unary_op_125(&children[0], parse_tree),

            126 => self.ident_126(&children[0], parse_tree),

            127 => self.integer_127(&children[0], parse_tree),

            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
