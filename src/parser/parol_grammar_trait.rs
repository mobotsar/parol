// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use crate::parser::parol_grammar::ParolGrammar;
use id_tree::Tree;
use miette::{miette, Result};
use parol_runtime::lexer::OwnedToken;
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

//
// Output Types of productions deduced from the structure of the transformed grammar
//

/// Type derived for production 0
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Parol0 {
    prolog_0: Box<Prolog>,
    grammar_definition_1: Box<GrammarDefinition>,
}

/// Type derived for production 1
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Prolog1 {
    start_declaration_0: Box<StartDeclaration>,
    prolog_list_1: Box<PrologList>,
    prolog_list1_2: Box<PrologList1>,
}

/// Type derived for production 6
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StartDeclaration6 {
    percent_start_0: OwnedToken, /* %start */
    identifier_1: Box<Identifier>,
}

/// Type derived for production 7
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Declaration7 {
    percent_title_0: OwnedToken, /* %title */
    string_1: Box<String>,
}

/// Type derived for production 8
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Declaration8 {
    percent_comment_0: OwnedToken, /* %comment */
    string_1: Box<String>,
}

/// Type derived for production 9
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Declaration9 {
    scanner_directives_0: Box<ScannerDirectives>,
}

/// Type derived for production 10
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ScannerDirectives10 {
    percent_line_underscore_comment_0: OwnedToken, /* %lineComment */
    string_1: Box<String>,
}

/// Type derived for production 11
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ScannerDirectives11 {
    percent_block_underscore_comment_0: OwnedToken, /* %blockComment */
    string_1: Box<String>,
    string_2: Box<String>,
}

/// Type derived for production 12
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ScannerDirectives12 {
    percent_auto_underscore_newline_underscore_off_0: OwnedToken, /* %autoNewlineOff */
}

/// Type derived for production 13
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ScannerDirectives13 {
    percent_auto_underscore_ws_underscore_off_0: OwnedToken, /* %autoWsOff */
}

/// Type derived for production 14
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct GrammarDefinition14 {
    percent_percent_0: OwnedToken, /* %% */
    production_1: Box<Production>,
    grammar_definition_list_2: Box<GrammarDefinitionList>,
}

/// Type derived for production 17
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Production17 {
    identifier_0: Box<Identifier>,
    colon_1: OwnedToken, /* : */
    alternations_2: Box<Alternations>,
    semicolon_3: OwnedToken, /* ; */
}

/// Type derived for production 18
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Alternations18 {
    alternation_0: Box<Alternation>,
    alternations_list_1: Box<AlternationsList>,
}

/// Type derived for production 21
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Alternation21 {
    alternation_list_0: Box<AlternationList>,
}

/// Type derived for production 24
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Factor24 {
    group_0: Box<Group>,
}

/// Type derived for production 25
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Factor25 {
    repeat_0: Box<Repeat>,
}

/// Type derived for production 26
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Factor26 {
    optional_0: Box<Optional>,
}

/// Type derived for production 27
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Factor27 {
    symbol_0: Box<Symbol>,
}

/// Type derived for production 28
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Symbol28 {
    identifier_0: Box<Identifier>,
}

/// Type derived for production 29
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Symbol29 {
    simple_token_0: Box<SimpleToken>,
}

/// Type derived for production 30
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Symbol30 {
    token_with_states_0: Box<TokenWithStates>,
}

/// Type derived for production 31
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Symbol31 {
    scanner_switch_0: Box<ScannerSwitch>,
}

/// Type derived for production 32
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct SimpleToken32 {
    string_0: Box<String>,
}

/// Type derived for production 33
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct TokenWithStates33 {
    l_t_0: OwnedToken, /* < */
    state_list_1: Box<StateList>,
    g_t_2: OwnedToken, /* > */
    string_3: Box<String>,
}

/// Type derived for production 34
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Group34 {
    l_paren_0: OwnedToken, /* \( */
    alternations_1: Box<Alternations>,
    r_paren_2: OwnedToken, /* \) */
}

/// Type derived for production 35
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Optional35 {
    l_bracket_0: OwnedToken, /* \[ */
    alternations_1: Box<Alternations>,
    r_bracket_2: OwnedToken, /* \] */
}

/// Type derived for production 36
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Repeat36 {
    l_brace_0: OwnedToken, /* \{ */
    alternations_1: Box<Alternations>,
    r_brace_2: OwnedToken, /* \} */
}

/// Type derived for production 37
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Identifier37 {
    identifier_0: OwnedToken, /* [a-zA-Z][a-zA-Z0-9]* */
}

/// Type derived for production 38
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct String38 {
    string_0: OwnedToken, /* \u{0022}([^\\]|\\.)*?\u{0022} */
}

/// Type derived for production 39
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ScannerState39 {
    percent_scanner_0: OwnedToken, /* %scanner */
    identifier_1: Box<Identifier>,
    l_brace_2: OwnedToken, /* \{ */
    scanner_state_list_3: Box<ScannerStateList>,
    r_brace_4: OwnedToken, /* \} */
}

/// Type derived for production 42
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StateList42 {
    identifier_0: Box<Identifier>,
    state_list_list_1: Box<StateListList>,
}

/// Type derived for production 45
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ScannerSwitch45 {
    percent_sc_0: OwnedToken, /* %sc */
    l_paren_1: OwnedToken,    /* \( */
    scanner_switch_suffix_2: Box<ScannerSwitchSuffix>,
}

/// Type derived for production 46
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ScannerSwitchSuffix46 {
    scanner_switch_opt_0: Box<ScannerSwitchOpt>,
    r_paren_1: OwnedToken, /* \) */
}

/// Type derived for production 47
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ScannerSwitchSuffix47 {
    r_paren_0: (),
}

/// Type derived for production 48
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ScannerSwitch48 {
    percent_push_0: OwnedToken, /* %push */
    l_paren_1: OwnedToken,      /* \( */
    identifier_2: Box<Identifier>,
    r_paren_3: OwnedToken, /* \) */
}

/// Type derived for production 49
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ScannerSwitch49 {
    percent_pop_0: OwnedToken, /* %pop */
    l_paren_1: OwnedToken,     /* \( */
    r_paren_2: OwnedToken,     /* \) */
}

/// Type derived for production 50
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ScannerSwitchOpt50 {
    identifier_0: Box<Identifier>,
}

//
// Types of non-terminals deduced from the structure of the transformed grammar
//

/// Type derived for non-terminal Alternation
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Alternation {
    alternation_list_0: Box<AlternationList>,
}

/// Type derived for non-terminal AlternationList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AlternationList {
    vec: Vec<Factor>,
}

/// Type derived for non-terminal Alternations
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Alternations {
    alternation_0: Box<Alternation>,
    alternations_list_1: Box<AlternationsList>,
}

/// Type derived for non-terminal AlternationsList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct AlternationsList {
    vec: Vec<(OwnedToken /* \| */, Alternation)>,
}

/// Type derived for non-terminal Declaration
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum Declaration {
    Declaration0(Box<Declaration7>),
    Declaration1(Box<Declaration8>),
    Declaration2(Box<Declaration9>),
}

/// Type derived for non-terminal Factor
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum Factor {
    Factor0(Box<Factor24>),
    Factor1(Box<Factor25>),
    Factor2(Box<Factor26>),
    Factor3(Box<Factor27>),
}

/// Type derived for non-terminal GrammarDefinition
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct GrammarDefinition {
    percent_percent_0: OwnedToken, /* %% */
    production_1: Box<Production>,
    grammar_definition_list_2: Box<GrammarDefinitionList>,
}

/// Type derived for non-terminal GrammarDefinitionList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct GrammarDefinitionList {
    vec: Vec<Production>,
}

/// Type derived for non-terminal Group
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Group {
    l_paren_0: OwnedToken, /* \( */
    alternations_1: Box<Alternations>,
    r_paren_2: OwnedToken, /* \) */
}

/// Type derived for non-terminal Identifier
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Identifier {
    identifier_0: OwnedToken, /* [a-zA-Z][a-zA-Z0-9]* */
}

/// Type derived for non-terminal Optional
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Optional {
    l_bracket_0: OwnedToken, /* \[ */
    alternations_1: Box<Alternations>,
    r_bracket_2: OwnedToken, /* \] */
}

/// Type derived for non-terminal Parol
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Parol {
    prolog_0: Box<Prolog>,
    grammar_definition_1: Box<GrammarDefinition>,
}

/// Type derived for non-terminal Production
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Production {
    identifier_0: Box<Identifier>,
    colon_1: OwnedToken, /* : */
    alternations_2: Box<Alternations>,
    semicolon_3: OwnedToken, /* ; */
}

/// Type derived for non-terminal Prolog
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Prolog {
    start_declaration_0: Box<StartDeclaration>,
    prolog_list_1: Box<PrologList>,
    prolog_list1_2: Box<PrologList1>,
}

/// Type derived for non-terminal PrologList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct PrologList {
    vec: Vec<Declaration>,
}

/// Type derived for non-terminal PrologList1
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct PrologList1 {
    vec: Vec<ScannerState>,
}

/// Type derived for non-terminal Repeat
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct Repeat {
    l_brace_0: OwnedToken, /* \{ */
    alternations_1: Box<Alternations>,
    r_brace_2: OwnedToken, /* \} */
}

/// Type derived for non-terminal ScannerDirectives
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum ScannerDirectives {
    ScannerDirectives0(Box<ScannerDirectives10>),
    ScannerDirectives1(Box<ScannerDirectives11>),
    ScannerDirectives2(Box<ScannerDirectives12>),
    ScannerDirectives3(Box<ScannerDirectives13>),
}

/// Type derived for non-terminal ScannerState
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ScannerState {
    percent_scanner_0: OwnedToken, /* %scanner */
    identifier_1: Box<Identifier>,
    l_brace_2: OwnedToken, /* \{ */
    scanner_state_list_3: Box<ScannerStateList>,
    r_brace_4: OwnedToken, /* \} */
}

/// Type derived for non-terminal ScannerStateList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ScannerStateList {
    vec: Vec<ScannerDirectives>,
}

/// Type derived for non-terminal ScannerSwitch
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum ScannerSwitch {
    ScannerSwitch0(Box<ScannerSwitch45>),
    ScannerSwitch1(Box<ScannerSwitch48>),
    ScannerSwitch2(Box<ScannerSwitch49>),
}

/// Type derived for non-terminal ScannerSwitchOpt
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct ScannerSwitchOpt {
    identifier_0: Box<Identifier>,
}

/// Type derived for non-terminal ScannerSwitchSuffix
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum ScannerSwitchSuffix {
    ScannerSwitchSuffix0(Box<ScannerSwitchSuffix46>),
    ScannerSwitchSuffix1(Box<ScannerSwitchSuffix47>),
}

/// Type derived for non-terminal SimpleToken
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct SimpleToken {
    string_0: Box<String>,
}

/// Type derived for non-terminal StartDeclaration
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StartDeclaration {
    percent_start_0: OwnedToken, /* %start */
    identifier_1: Box<Identifier>,
}

/// Type derived for non-terminal StateList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StateList {
    identifier_0: Box<Identifier>,
    state_list_list_1: Box<StateListList>,
}

/// Type derived for non-terminal StateListList
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct StateListList {
    vec: Vec<(OwnedToken /* , */, Identifier)>,
}

/// Type derived for non-terminal String
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct String {
    string_0: OwnedToken, /* \u{0022}([^\\]|\\.)*?\u{0022} */
}

/// Type derived for non-terminal Symbol
#[allow(dead_code)]
#[derive(Debug, Clone)]
enum Symbol {
    Symbol0(Box<Symbol28>),
    Symbol1(Box<Symbol29>),
    Symbol2(Box<Symbol30>),
    Symbol3(Box<Symbol31>),
}

/// Type derived for non-terminal TokenWithStates
#[allow(dead_code)]
#[derive(Debug, Clone)]
struct TokenWithStates {
    l_t_0: OwnedToken, /* < */
    state_list_1: Box<StateList>,
    g_t_2: OwnedToken, /* > */
    string_3: Box<String>,
}

///
/// The `ParolGrammarTrait` trait is automatically generated for the
/// given grammar.
/// All functions have default implementations.
///
pub trait ParolGrammarTrait {
    ///
    /// Implement this method if you need the provided information
    ///
    fn init(&mut self, _file_name: &std::path::Path) {}

    /// Semantic action for production 0:
    ///
    /// Parol: Prolog GrammarDefinition;
    ///
    fn parol_0(
        &mut self,
        _prolog_0: &ParseTreeStackEntry,
        _grammar_definition_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Prolog: StartDeclaration PrologList PrologList1;
    ///
    fn prolog_1(
        &mut self,
        _start_declaration_0: &ParseTreeStackEntry,
        _prolog_list_1: &ParseTreeStackEntry,
        _prolog_list1_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// PrologList1: ScannerState PrologList1;
    ///
    fn prolog_list1_2(
        &mut self,
        _scanner_state_0: &ParseTreeStackEntry,
        _prolog_list1_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// PrologList1: /* Vec<PrologList1>::New */;
    ///
    fn prolog_list1_3(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// PrologList: Declaration PrologList;
    ///
    fn prolog_list_4(
        &mut self,
        _declaration_0: &ParseTreeStackEntry,
        _prolog_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// PrologList: /* Vec<PrologList>::New */;
    ///
    fn prolog_list_5(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// StartDeclaration: "%start" Identifier;
    ///
    fn start_declaration_6(
        &mut self,
        _percent_start_0: &ParseTreeStackEntry,
        _identifier_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// Declaration: "%title" String;
    ///
    fn declaration_7(
        &mut self,
        _percent_title_0: &ParseTreeStackEntry,
        _string_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// Declaration: "%comment" String;
    ///
    fn declaration_8(
        &mut self,
        _percent_comment_0: &ParseTreeStackEntry,
        _string_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// Declaration: ScannerDirectives;
    ///
    fn declaration_9(
        &mut self,
        _scanner_directives_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// ScannerDirectives: "%line_comment" String;
    ///
    fn scanner_directives_10(
        &mut self,
        _percent_line_underscore_comment_0: &ParseTreeStackEntry,
        _string_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// ScannerDirectives: "%block_comment" String String;
    ///
    fn scanner_directives_11(
        &mut self,
        _percent_block_underscore_comment_0: &ParseTreeStackEntry,
        _string_1: &ParseTreeStackEntry,
        _string_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// ScannerDirectives: "%auto_newline_off";
    ///
    fn scanner_directives_12(
        &mut self,
        _percent_auto_underscore_newline_underscore_off_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// ScannerDirectives: "%auto_ws_off";
    ///
    fn scanner_directives_13(
        &mut self,
        _percent_auto_underscore_ws_underscore_off_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// GrammarDefinition: "%%" Production GrammarDefinitionList;
    ///
    fn grammar_definition_14(
        &mut self,
        _percent_percent_0: &ParseTreeStackEntry,
        _production_1: &ParseTreeStackEntry,
        _grammar_definition_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// GrammarDefinitionList: Production GrammarDefinitionList;
    ///
    fn grammar_definition_list_15(
        &mut self,
        _production_0: &ParseTreeStackEntry,
        _grammar_definition_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// GrammarDefinitionList: /* Vec<GrammarDefinitionList>::New */;
    ///
    fn grammar_definition_list_16(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// Production: Identifier ":" Alternations ";";
    ///
    fn production_17(
        &mut self,
        _identifier_0: &ParseTreeStackEntry,
        _colon_1: &ParseTreeStackEntry,
        _alternations_2: &ParseTreeStackEntry,
        _semicolon_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// Alternations: Alternation AlternationsList;
    ///
    fn alternations_18(
        &mut self,
        _alternation_0: &ParseTreeStackEntry,
        _alternations_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// AlternationsList: "\|" Alternation AlternationsList;
    ///
    fn alternations_list_19(
        &mut self,
        _or_0: &ParseTreeStackEntry,
        _alternation_1: &ParseTreeStackEntry,
        _alternations_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// AlternationsList: /* Vec<AlternationsList>::New */;
    ///
    fn alternations_list_20(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// Alternation: AlternationList;
    ///
    fn alternation_21(
        &mut self,
        _alternation_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// AlternationList: Factor AlternationList;
    ///
    fn alternation_list_22(
        &mut self,
        _factor_0: &ParseTreeStackEntry,
        _alternation_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// AlternationList: /* Vec<AlternationList>::New */;
    ///
    fn alternation_list_23(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// Factor: Group;
    ///
    fn factor_24(
        &mut self,
        _group_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// Factor: Repeat;
    ///
    fn factor_25(
        &mut self,
        _repeat_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// Factor: Optional;
    ///
    fn factor_26(
        &mut self,
        _optional_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// Factor: Symbol;
    ///
    fn factor_27(
        &mut self,
        _symbol_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// Symbol: Identifier;
    ///
    fn symbol_28(
        &mut self,
        _identifier_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// Symbol: SimpleToken;
    ///
    fn symbol_29(
        &mut self,
        _simple_token_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// Symbol: TokenWithStates;
    ///
    fn symbol_30(
        &mut self,
        _token_with_states_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// Symbol: ScannerSwitch;
    ///
    fn symbol_31(
        &mut self,
        _scanner_switch_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// SimpleToken: String;
    ///
    fn simple_token_32(
        &mut self,
        _string_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// TokenWithStates: "<" StateList ">" String;
    ///
    fn token_with_states_33(
        &mut self,
        _l_t_0: &ParseTreeStackEntry,
        _state_list_1: &ParseTreeStackEntry,
        _g_t_2: &ParseTreeStackEntry,
        _string_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// Group: "\(" Alternations "\)";
    ///
    fn group_34(
        &mut self,
        _l_paren_0: &ParseTreeStackEntry,
        _alternations_1: &ParseTreeStackEntry,
        _r_paren_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// Optional: "\[" Alternations "\]";
    ///
    fn optional_35(
        &mut self,
        _l_bracket_0: &ParseTreeStackEntry,
        _alternations_1: &ParseTreeStackEntry,
        _r_bracket_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// Repeat: "\{" Alternations "\}";
    ///
    fn repeat_36(
        &mut self,
        _l_brace_0: &ParseTreeStackEntry,
        _alternations_1: &ParseTreeStackEntry,
        _r_brace_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// Identifier: "[a-zA-Z_][a-zA-Z0-9_]*";
    ///
    fn identifier_37(
        &mut self,
        _identifier_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// String: "\u{0022}([^\\]|\\.)*?\u{0022}";
    ///
    fn string_38(
        &mut self,
        _string_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// ScannerState: "%scanner" Identifier "\{" ScannerStateList "\}";
    ///
    fn scanner_state_39(
        &mut self,
        _percent_scanner_0: &ParseTreeStackEntry,
        _identifier_1: &ParseTreeStackEntry,
        _l_brace_2: &ParseTreeStackEntry,
        _scanner_state_list_3: &ParseTreeStackEntry,
        _r_brace_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// ScannerStateList: ScannerDirectives ScannerStateList;
    ///
    fn scanner_state_list_40(
        &mut self,
        _scanner_directives_0: &ParseTreeStackEntry,
        _scanner_state_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// ScannerStateList: /* Vec<ScannerStateList>::New */;
    ///
    fn scanner_state_list_41(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// StateList: Identifier StateListList;
    ///
    fn state_list_42(
        &mut self,
        _identifier_0: &ParseTreeStackEntry,
        _state_list_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// StateListList: "," Identifier StateListList;
    ///
    fn state_list_list_43(
        &mut self,
        _comma_0: &ParseTreeStackEntry,
        _identifier_1: &ParseTreeStackEntry,
        _state_list_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// StateListList: /* Vec<StateListList>::New */;
    ///
    fn state_list_list_44(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// ScannerSwitch: "%sc" "\(" ScannerSwitchSuffix;
    ///
    fn scanner_switch_45(
        &mut self,
        _percent_sc_0: &ParseTreeStackEntry,
        _l_paren_1: &ParseTreeStackEntry,
        _scanner_switch_suffix_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// ScannerSwitchSuffix: ScannerSwitchOpt "\)";
    ///
    fn scanner_switch_suffix_46(
        &mut self,
        _scanner_switch_opt_0: &ParseTreeStackEntry,
        _r_paren_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// ScannerSwitchSuffix: /* Option<ScannerSwitchOpt>::None */ "\)";
    ///
    fn scanner_switch_suffix_47(
        &mut self,
        _r_paren_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// ScannerSwitch: "%push" "\(" Identifier "\)";
    ///
    fn scanner_switch_48(
        &mut self,
        _percent_push_0: &ParseTreeStackEntry,
        _l_paren_1: &ParseTreeStackEntry,
        _identifier_2: &ParseTreeStackEntry,
        _r_paren_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// ScannerSwitch: "%pop" "\(" "\)";
    ///
    fn scanner_switch_49(
        &mut self,
        _percent_pop_0: &ParseTreeStackEntry,
        _l_paren_1: &ParseTreeStackEntry,
        _r_paren_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// ScannerSwitchOpt: Identifier;
    ///
    fn scanner_switch_opt_50(
        &mut self,
        _identifier_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }
}

impl UserActionsTrait for ParolGrammar {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// Is is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, file_name: &std::path::Path) {
        ParolGrammarTrait::init(self, file_name);
    }

    ///
    /// This function is implemented automatically for the user's item ParolGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry],
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        match prod_num {
            0 => self.parol_0(&children[0], &children[1], parse_tree),

            1 => self.prolog_1(&children[0], &children[1], &children[2], parse_tree),

            2 => self.prolog_list1_2(&children[0], &children[1], parse_tree),

            3 => self.prolog_list1_3(parse_tree),

            4 => self.prolog_list_4(&children[0], &children[1], parse_tree),

            5 => self.prolog_list_5(parse_tree),

            6 => self.start_declaration_6(&children[0], &children[1], parse_tree),

            7 => self.declaration_7(&children[0], &children[1], parse_tree),

            8 => self.declaration_8(&children[0], &children[1], parse_tree),

            9 => self.declaration_9(&children[0], parse_tree),

            10 => self.scanner_directives_10(&children[0], &children[1], parse_tree),

            11 => self.scanner_directives_11(&children[0], &children[1], &children[2], parse_tree),

            12 => self.scanner_directives_12(&children[0], parse_tree),

            13 => self.scanner_directives_13(&children[0], parse_tree),

            14 => self.grammar_definition_14(&children[0], &children[1], &children[2], parse_tree),

            15 => self.grammar_definition_list_15(&children[0], &children[1], parse_tree),

            16 => self.grammar_definition_list_16(parse_tree),

            17 => self.production_17(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            18 => self.alternations_18(&children[0], &children[1], parse_tree),

            19 => self.alternations_list_19(&children[0], &children[1], &children[2], parse_tree),

            20 => self.alternations_list_20(parse_tree),

            21 => self.alternation_21(&children[0], parse_tree),

            22 => self.alternation_list_22(&children[0], &children[1], parse_tree),

            23 => self.alternation_list_23(parse_tree),

            24 => self.factor_24(&children[0], parse_tree),

            25 => self.factor_25(&children[0], parse_tree),

            26 => self.factor_26(&children[0], parse_tree),

            27 => self.factor_27(&children[0], parse_tree),

            28 => self.symbol_28(&children[0], parse_tree),

            29 => self.symbol_29(&children[0], parse_tree),

            30 => self.symbol_30(&children[0], parse_tree),

            31 => self.symbol_31(&children[0], parse_tree),

            32 => self.simple_token_32(&children[0], parse_tree),

            33 => self.token_with_states_33(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            34 => self.group_34(&children[0], &children[1], &children[2], parse_tree),

            35 => self.optional_35(&children[0], &children[1], &children[2], parse_tree),

            36 => self.repeat_36(&children[0], &children[1], &children[2], parse_tree),

            37 => self.identifier_37(&children[0], parse_tree),

            38 => self.string_38(&children[0], parse_tree),

            39 => self.scanner_state_39(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),

            40 => self.scanner_state_list_40(&children[0], &children[1], parse_tree),

            41 => self.scanner_state_list_41(parse_tree),

            42 => self.state_list_42(&children[0], &children[1], parse_tree),

            43 => self.state_list_list_43(&children[0], &children[1], &children[2], parse_tree),

            44 => self.state_list_list_44(parse_tree),

            45 => self.scanner_switch_45(&children[0], &children[1], &children[2], parse_tree),

            46 => self.scanner_switch_suffix_46(&children[0], &children[1], parse_tree),

            47 => self.scanner_switch_suffix_47(&children[0], parse_tree),

            48 => self.scanner_switch_48(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),

            49 => self.scanner_switch_49(&children[0], &children[1], &children[2], parse_tree),

            50 => self.scanner_switch_opt_50(&children[0], parse_tree),

            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
